# 7차시: 백테스트 시스템 구축

## 1번 프롬프트

```text
백테스트 시스템의 핵심 구성 요소를 설명해줘. 
데이터 로딩, 전략 실행, 성과 분석, 
결과 시각화의 각 단계를 자세히 설명해줘.
```

### 프롬프트 분석 및 구현

백테스트 시스템은 과거 데이터를 사용하여 거래 전략의 성과를 시뮬레이션하는 시스템입니다. 핵심 구성 요소는 다음과 같습니다:

#### 1. 데이터 로딩 (Data Loading)
- **목적**: 백테스트에 필요한 과거 시장 데이터를 수집하고 준비
- **주요 기능**: 데이터 소스 연결, 데이터 정제, 데이터 변환, 데이터 검증
- **구현**: `DataLoader` 클래스로 모듈화하여 API, CSV 파일, 데이터베이스 등 다양한 소스에서 데이터 수집

#### 2. 전략 실행 (Strategy Execution)
- **목적**: 정의된 거래 전략을 과거 데이터에 적용하여 거래 신호 생성
- **주요 기능**: 신호 생성, 포지션 관리, 리스크 관리, 거래 시뮬레이션
- **구현**: `TradingStrategy` 클래스로 전략 로직을 구현하고 실제 거래와 유사한 환경에서 실행

#### 3. 성과 분석 (Performance Analysis)
- **목적**: 백테스트 결과를 분석하여 전략의 수익성과 위험도 평가
- **주요 기능**: 수익성 지표, 위험 지표, 거래 통계, 벤치마크 비교
- **구현**: `PerformanceAnalyzer` 클래스로 샤프 비율, 최대 낙폭, VaR 등 다양한 지표 계산

#### 4. 결과 시각화 (Result Visualization)
- **목적**: 백테스트 결과를 직관적으로 이해할 수 있도록 차트와 그래프로 표현
- **주요 기능**: 가격 차트, 수익률 차트, 분포 차트, 성과 대시보드
- **구현**: `ResultVisualizer` 클래스로 matplotlib, plotly 등을 활용한 시각화

#### 5. 통합 시스템 구조
- **BacktestSystem 클래스**: 4개 핵심 모듈을 통합하여 완전한 백테스트 시스템 구축
- **핵심 특징**: 정확성, 재현성, 확장성, 성능 최적화
- **고려사항**: 데이터 품질, 전략 구현, 성과 분석, 시각화의 각 영역별 주의사항

## 2번 프롬프트

```text
백테스트의 중요성과 한계점을 설명해줘. 
과거 데이터 기반 검증의 의미와 
실제 거래와의 차이점을 분석해줘.
```

### 프롬프트 분석 및 구현

백테스트는 거래 전략의 성과를 과거 데이터로 검증하는 중요한 도구이지만, 한계점도 존재합니다.

#### 1. 백테스트의 중요성
- **전략 검증**: 과거 성과 확인, 리스크 평가, 매개변수 최적화
- **의사결정 지원**: 투자 결정, 자금 배분, 리스크 관리에 객관적 근거 제공
- **학습 및 개선**: 전략 이해, 개선 방향 도출, 새로운 아이디어 테스트

#### 2. 백테스트의 한계점
- **과거 데이터 한계**: 미래 보장 불가, 시장 변화, 데이터 편향
- **실제 거래와의 차이**: 거래 비용, 유동성 제약, 심리적 요인, 시장 미시구조
- **기술적 한계**: 과최적화, 데이터 마이닝 편향, 생존자 편향, 룩어헤드 편향

#### 3. 과거 데이터 기반 검증의 의미
- **통계적 유의성**: 충분한 샘플, 다양한 시장 상황, 외부 검증
- **전략의 견고성**: 매개변수 민감도, 시장 상황별 성과, 리스크 조정 수익률
- **실용성 검증**: 실행 가능성, 비용 고려, 자금 관리

#### 4. 실제 거래와의 차이점
- **거래 실행**: 가격(이론적 vs 실제), 체결(100% vs 불가능성), 비용(무시 vs 실제), 심리(감정 없음 vs 공포/탐욕)
- **시장 환경**: 유동성(무제한 vs 제한적), 시장 충격(무시 vs 존재), 호가창(단순화 vs 복잡), 뉴스(과거 vs 실시간)
- **리스크 관리**: 손절(즉시 vs 지연), 포지션 크기(정확한 계산 vs 감정적 판단), 모니터링(자동화 vs 수동)

#### 5. 백테스트 신뢰성 향상 방법
- **데이터 품질 개선**: 충분한 기간(5년 이상), 다양한 시장 상황, 거래 비용 반영, 유동성 제약 고려
- **과최적화 방지**: 매개변수 범위 제한, 교차 검증, 단순한 전략 선호, 외부 검증 필수
- **현실적 가정 적용**: 거래 비용 반영, 체결 지연 고려, 유동성 제약, 시장 시간 고려

#### 6. 결과 해석 가이드
- **성과 지표**: 샤프 비율 1.0 이상 양호, 최대 낙폭 20% 이하 바람직, 승률 50% 이상 양호
- **리스크 지표**: 변동성, VaR, 상관관계 등 종합적 평가
- **실용성 평가**: 실행 가능성, 비용 효율성, 자금 요구사항 확인

#### 7. 결론 및 권장사항
- **올바른 활용**: 전략 검증 도구, 리스크 사전 파악, 개선 방향 제시, 의사결정 지원
- **실제 거래 준비**: 점진적 적용, 지속적 모니터링, 유연한 대응, 엄격한 리스크 관리
- **핵심 메시지**: 백테스트는 시작일 뿐, 과거 성과 ≠ 미래 성과, 보수적 접근 필요

## 3번 프롬프트

```text
변동성 돌파 전략을 위한 백테스트 클래스를 만들어줘. 
데이터 로딩, 전략 실행, 성과 분석 기능을 포함하고, 
pandas를 사용해서 효율적으로 작성해줘.
```

### 프롬프트 분석 및 구현

변동성 돌파 전략을 위한 백테스트 클래스를 pandas를 활용하여 효율적으로 구현합니다.

#### 1. 클래스 구조 설계
- **VolatilityBreakoutBacktest 클래스**: 변동성 돌파 전략 백테스트의 핵심 클래스
- **데이터 로딩**: pandas를 활용한 효율적인 OHLCV 데이터 처리
- **전략 실행**: 돌파선 계산, 매수/매도 신호 생성, 포지션 관리
- **성과 분석**: 수익률, 리스크 지표, 거래 통계 계산

#### 2. 주요 기능
- **데이터 관리**: pandas DataFrame을 활용한 시계열 데이터 처리
- **전략 로직**: K값 기반 돌파선 계산, 거래량/RSI 필터 적용
- **리스크 관리**: 손절/익절, 시간 기반 청산, 포지션 크기 제한
- **성과 분석**: 누적 수익률, 샤프 비율, 최대 낙폭, 승률 등 계산

#### 3. pandas 최적화
- **벡터화 연산**: 반복문 대신 pandas의 벡터화 연산 활용
- **인덱싱 최적화**: DatetimeIndex를 활용한 효율적인 시계열 데이터 접근
- **메모리 효율성**: 필요한 컬럼만 선택하여 메모리 사용량 최적화
- **성능 향상**: rolling, shift 등 pandas 내장 함수 활용

#### 4. 구현 특징
- **모듈화 설계**: 데이터 로딩, 전략 실행, 성과 분석을 별도 메서드로 분리
- **유연한 매개변수**: K값, 손절/익절 비율, 필터 조건 등을 쉽게 조정 가능
- **상세한 로깅**: 거래 내역, 성과 지표를 자세히 기록
- **시각화 지원**: matplotlib을 활용한 차트 생성 기능 포함

## 4번 프롬프트

```text
백테스트 결과를 시각화하는 시스템을 만들어줘. 
수익률 곡선, 낙폭 차트, 월별 수익률 히트맵, 
거래 내역 차트를 matplotlib로 그려줘.
```

### 프롬프트 분석 및 구현

백테스트 결과를 직관적으로 이해할 수 있도록 다양한 차트를 matplotlib으로 구현합니다.

#### 1. 시각화 시스템 구성 요소
- **수익률 곡선**: 시간에 따른 누적 수익률 변화를 선형 차트로 표현
- **낙폭 차트**: 최대 낙폭(MDD) 분석을 위한 드로우다운 차트
- **월별 수익률 히트맵**: 월별 수익률을 색상으로 표현한 히트맵
- **거래 내역 차트**: 매수/매도 포인트를 가격 차트에 표시

#### 2. 주요 시각화 기능
- **누적 수익률 차트**: 벤치마크 대비 전략 성과 비교
- **드로우다운 분석**: 손실 기간과 회복 기간 분석
- **성과 분포**: 월별/연도별 수익률 분포 및 통계
- **거래 분석**: 매수/매도 시점, 수익/손실 거래 비율

#### 3. matplotlib 최적화
- **스타일 설정**: 한글 폰트 설정, 색상 팔레트, 차트 스타일
- **레이아웃 관리**: subplot을 활용한 다중 차트 배치
- **인터랙티브 요소**: 마우스 호버 정보, 줌 기능, 범례 설정
- **고해상도 출력**: PNG, PDF 등 다양한 형식으로 저장

#### 4. 구현 특징
- **모듈화 설계**: 각 차트를 별도 메서드로 분리하여 재사용성 향상
- **커스터마이징**: 차트 스타일, 색상, 크기 등을 쉽게 조정 가능
- **성능 최적화**: 대용량 데이터 처리 시 메모리 효율성 고려
- **저장 기능**: 차트를 이미지 파일로 저장하여 리포트 작성 지원

## 5번 프롬프트

```text
현재 백테스트 코드의 정확성을 검토해줘. 
매수/매도 조건, 수익률 계산, 
거래 비용 반영 등이 올바른지 확인해줘.
```

### 프롬프트 분석 및 구현

백테스트 코드의 정확성 검토는 신뢰할 수 있는 결과를 얻기 위한 필수 과정입니다.

#### 1. 매수/매도 조건 검토
- **신호 생성 로직**: 전략별 매수/매도 조건이 올바르게 구현되었는지 확인
- **타이밍 정확성**: 실제 거래 시간과 백테스트 시간의 일치 여부 검증
- **중복 신호 처리**: 동일한 시간대에 여러 신호가 발생할 때의 처리 방식 확인
- **포지션 상태 관리**: 이미 포지션이 있을 때 새로운 신호 처리 로직 검토

#### 2. 수익률 계산 검증
- **일일 수익률 계산**: (종가 - 전일종가) / 전일종가 공식 정확성 확인
- **누적 수익률 계산**: 복리 계산 방식과 단리 계산 방식 구분
- **포지션별 수익률**: 매수/매도 시점의 정확한 가격 적용 여부
- **수수료 차감**: 거래 시 수수료가 올바르게 차감되었는지 확인

#### 3. 거래 비용 반영 검토
- **수수료 구조**: 거래소별 수수료율 정확성 (업비트 0.05% 등)
- **슬리피지 고려**: 시장가 주문 시 예상 가격과 실제 체결가 차이
- **거래세 반영**: 한국의 경우 암호화폐 거래세 고려 여부
- **시간 지연**: 주문 신호 발생과 실제 체결 사이의 지연 시간

#### 4. 데이터 정확성 검증
- **가격 데이터**: OHLCV 데이터의 정확성과 완전성 확인
- **누락 데이터**: 공휴일이나 장 마감 시간 데이터 처리 방식
- **데이터 정규화**: 분할, 배당 등 기업 행사 반영 여부
- **시간대 일치**: 백테스트 시간대와 실제 거래 시간대 일치

#### 5. 백테스트 가정 검토
- **유동성 가정**: 실제 거래 가능한 수량인지 확인
- **체결 가정**: 모든 주문이 즉시 체결된다는 가정의 현실성
- **자금 관리**: 초기 자금과 레버리지 사용의 정확성
- **리스크 관리**: 손절/익절 로직의 실행 가능성

#### 6. 성과 지표 검증
- **샤프 비율**: 무위험 수익률 설정과 변동성 계산 정확성
- **최대 낙폭**: 드로우다운 계산 방식과 기간 설정 확인
- **승률**: 수익 거래 비율 계산의 정확성
- **거래 횟수**: 실제 거래 발생 횟수와 통계 일치성

#### 7. 코드 품질 검토
- **로직 일관성**: 매수/매도 로직의 일관된 구현
- **경계 조건**: 데이터 시작/종료 시점 처리 방식
- **오류 처리**: 예외 상황에 대한 적절한 처리
- **재현성**: 동일한 입력에 대해 항상 같은 결과 생성

#### 8. 검증 방법론
- **단위 테스트**: 각 함수별 정확성 검증
- **통합 테스트**: 전체 백테스트 프로세스 검증
- **수동 검증**: 소규모 데이터셋으로 수동 계산과 비교
- **크로스 체크**: 다른 백테스트 도구와 결과 비교

#### 9. 일반적인 오류 유형
- **룩어헤드 편향**: 미래 정보를 과거에 사용하는 오류
- **과최적화**: 과도한 매개변수 튜닝으로 인한 과적합
- **생존자 편향**: 현재 상장된 코인만 사용하는 편향
- **거래 비용 무시**: 수수료나 슬리피지를 고려하지 않는 오류

#### 10. 검증 체크리스트
- [ ] 매수/매도 신호가 전략 조건에 맞게 생성되는가?
- [ ] 수익률 계산이 수학적으로 정확한가?
- [ ] 거래 비용이 올바르게 반영되었는가?
- [ ] 데이터에 누락이나 오류가 없는가?
- [ ] 백테스트 가정이 현실적인가?
- [ ] 성과 지표가 올바르게 계산되었는가?
- [ ] 코드가 재현 가능한가?
- [ ] 경계 조건이 적절히 처리되었는가?

## 6번 프롬프트

```text
백테스트 코드에 강력한 오류 처리를 추가해줘. 
데이터 누락, 계산 오류, 메모리 부족 등 
다양한 예외 상황을 처리해줘.
```

### 프롬프트 분석 및 구현

강력한 오류 처리는 안정적이고 신뢰할 수 있는 백테스트 시스템을 구축하기 위한 핵심 요소입니다.

#### 1. 데이터 관련 오류 처리
- **데이터 누락**: 결측값(NA, NaN) 처리, 공휴일 데이터 누락 대응
- **데이터 형식 오류**: 잘못된 데이터 타입, 형식 불일치 처리
- **데이터 무결성**: 가격 데이터의 논리적 오류 (음수 가격, 비정상적 변동) 검증
- **데이터 범위 오류**: 예상 범위를 벗어난 데이터 값 처리
- **파일 접근 오류**: 데이터 파일이 존재하지 않거나 읽기 권한이 없는 경우

#### 2. 계산 오류 처리
- **수학적 오류**: 0으로 나누기, 음수 로그, 무한대 값 처리
- **오버플로우/언더플로우**: 큰 수 계산 시 발생하는 오류 처리
- **수치 안정성**: 부동소수점 연산의 정밀도 문제 해결
- **통계 계산 오류**: 표준편차 0, 상관관계 계산 오류 처리
- **인덱스 오류**: 배열 범위 초과, 잘못된 인덱스 접근 처리

#### 3. 메모리 관련 오류 처리
- **메모리 부족**: 대용량 데이터 처리 시 메모리 부족 상황 대응
- **메모리 누수**: 객체 참조 해제, 가비지 컬렉션 최적화
- **메모리 효율성**: 청크 단위 데이터 처리, 스트리밍 방식 구현
- **캐시 관리**: 메모리 캐시 크기 제한, LRU 캐시 구현
- **병렬 처리**: 멀티프로세싱 시 메모리 공유 문제 해결

#### 4. 네트워크 및 API 오류 처리
- **연결 오류**: 인터넷 연결 불안정, API 서버 다운 상황
- **API 제한**: 요청 한도 초과, 속도 제한 대응
- **응답 오류**: 잘못된 API 응답, 타임아웃 처리
- **인증 오류**: API 키 만료, 권한 부족 상황
- **데이터 동기화**: 실시간 데이터와 백테스트 데이터 불일치 처리

#### 5. 백테스트 로직 오류 처리
- **전략 실행 오류**: 전략 매개변수 오류, 논리적 오류 처리
- **포지션 관리 오류**: 포지션 크기 계산 오류, 잔고 부족 상황
- **리스크 관리 오류**: 손절/익절 조건 오류, 리스크 한도 초과
- **거래 시뮬레이션 오류**: 체결 불가능한 주문, 유동성 부족 상황
- **성과 계산 오류**: 성과 지표 계산 시 발생하는 오류 처리

#### 6. 시스템 리소스 오류 처리
- **디스크 공간 부족**: 로그 파일, 결과 파일 저장 시 공간 부족
- **CPU 과부하**: 계산 집약적 작업 시 CPU 사용률 관리
- **파일 시스템 오류**: 파일 쓰기/읽기 권한, 디렉토리 생성 오류
- **프로세스 관리**: 백그라운드 프로세스 관리, 좀비 프로세스 처리
- **시스템 종료**: 갑작스러운 시스템 종료 시 데이터 보존

#### 7. 오류 처리 구현 패턴
- **Try-Catch 블록**: 예외 상황을 포착하고 적절히 처리
- **로깅 시스템**: 오류 발생 시 상세한 로그 기록
- **재시도 메커니즘**: 일시적 오류에 대한 자동 재시도
- **폴백 전략**: 오류 발생 시 대안적 처리 방식 제공
- **회복 메커니즘**: 오류 발생 후 시스템 상태 복구

#### 8. 사용자 정의 예외 클래스
- **DataError**: 데이터 관련 오류를 위한 커스텀 예외
- **CalculationError**: 계산 오류를 위한 커스텀 예외
- **MemoryError**: 메모리 관련 오류를 위한 커스텀 예외
- **BacktestError**: 백테스트 전용 오류를 위한 커스텀 예외
- **ConfigurationError**: 설정 관련 오류를 위한 커스텀 예외

#### 9. 오류 모니터링 및 알림
- **실시간 모니터링**: 오류 발생 시 즉시 감지 및 알림
- **오류 통계**: 오류 발생 빈도, 유형별 통계 수집
- **성능 지표**: 오류 처리 시간, 시스템 복구 시간 측정
- **알림 시스템**: 중요한 오류 발생 시 텔레그램, 이메일 알림
- **대시보드**: 오류 현황을 시각적으로 모니터링

#### 10. 오류 처리 모범 사례
- **방어적 프로그래밍**: 입력 검증, 경계 조건 확인
- **Graceful Degradation**: 오류 발생 시에도 기본 기능 유지
- **상세한 오류 메시지**: 디버깅을 위한 명확한 오류 정보 제공
- **오류 복구 전략**: 자동 복구 vs 수동 개입 판단 기준
- **문서화**: 오류 처리 방식과 대응 절차 문서화

#### 11. 구현 예시
- **데이터 검증**: pandas의 isna(), isinf() 함수 활용
- **메모리 관리**: gc.collect(), del 키워드로 메모리 해제
- **재시도 로직**: decorator 패턴으로 재시도 메커니즘 구현
- **로깅**: logging 모듈을 활용한 구조화된 로그 기록
- **설정 검증**: pydantic을 활용한 설정 값 유효성 검사

#### 12. 테스트 및 검증
- **오류 시나리오 테스트**: 의도적으로 오류를 발생시켜 테스트
- **스트레스 테스트**: 극한 상황에서의 시스템 안정성 검증
- **복구 테스트**: 오류 발생 후 시스템 복구 능력 확인
- **성능 테스트**: 오류 처리로 인한 성능 저하 측정
- **사용자 테스트**: 실제 사용 환경에서의 오류 처리 검증

## 7번 프롬프트

```text
정확한 수익률 계산 로직을 구현해줘. 
거래 수수료, 슬리피지, 
복리 효과를 모두 반영해서 계산해줘.
```

### 프롬프트 분석 및 구현

정확한 수익률 계산은 백테스트의 신뢰성을 보장하는 핵심 요소입니다. 실제 거래 환경을 최대한 반영하여 현실적인 성과를 계산합니다.

#### 1. 기본 수익률 계산 원리
- **일일 수익률**: (현재가 - 전일종가) / 전일종가 × 100
- **누적 수익률**: (1 + r1) × (1 + r2) × ... × (1 + rn) - 1
- **연환산 수익률**: (1 + 누적수익률)^(365/거래일수) - 1
- **로그 수익률**: ln(현재가 / 전일종가) - 정규분포 가정 하에서 사용
- **단순 수익률 vs 복리 수익률**: 투자 기간에 따른 계산 방식 선택

#### 2. 거래 수수료 반영
- **업비트 수수료**: 매수/매도 각각 0.05% (0.0005)
- **총 거래 비용**: 매수 수수료 + 매도 수수료 = 0.1%
- **수수료 계산**: 거래 금액 × 수수료율
- **순 수익률**: 거래 수익률 - 거래 수수료
- **수수료 최적화**: 거래 빈도가 높을수록 수수료 부담 증가

#### 3. 슬리피지(Slippage) 반영
- **슬리피지 정의**: 예상 가격과 실제 체결 가격의 차이
- **시장가 주문**: 호가창 스프레드만큼 불리한 가격 체결
- **지정가 주문**: 체결 불가능성으로 인한 기회 비용
- **슬리피지 모델링**: 
  - 고정 슬리피지: 거래 금액의 0.01% ~ 0.05%
  - 변동 슬리피지: 거래량과 유동성에 따라 조정
  - 확률적 슬리피지: 정규분포 기반 랜덤 슬리피지

#### 4. 복리 효과 반영
- **복리 계산**: 각 거래의 수익을 다음 거래의 원금에 반영
- **자본 증감**: 수익 거래 시 자본 증가, 손실 거래 시 자본 감소
- **포지션 크기**: 현재 자본 대비 고정 비율로 포지션 조정
- **수익률 연쇄**: 이전 거래 수익률이 다음 거래에 미치는 영향
- **복리 vs 단리**: 장기 투자에서 복리 효과가 더욱 중요

#### 5. 거래 시뮬레이션 로직
- **거래 전 자본**: 매수 전 현재 보유 자본
- **거래 후 자본**: 매도 후 최종 보유 자본
- **수수료 차감**: 매수/매도 시점에서 각각 수수료 차감
- **슬리피지 적용**: 실제 체결 가격에 슬리피지 반영
- **자본 업데이트**: 거래 완료 후 자본 상태 업데이트

#### 6. 수익률 지표 계산
- **총 수익률**: (최종 자본 - 초기 자본) / 초기 자본 × 100
- **연평균 수익률**: (최종자본/초기자본)^(1/연수) - 1
- **샤프 비율**: (연평균수익률 - 무위험수익률) / 변동성
- **최대 낙폭**: 최고점 대비 최대 손실률
- **승률**: 수익 거래 수 / 전체 거래 수 × 100

#### 7. 구현 세부사항
- **거래 단위**: 최소 거래 단위 고려 (업비트 5,000원 이상)
- **자본 관리**: 거래 가능 자본의 일정 비율만 투자
- **부분 체결**: 대량 거래 시 부분 체결 상황 시뮬레이션
- **시간 지연**: 신호 발생과 실제 체결 사이의 시간 지연
- **유동성 제약**: 시장 유동성 부족 시 체결 지연 또는 불가

#### 8. 수익률 계산 클래스 구조
- **ReturnCalculator 클래스**: 수익률 계산의 핵심 클래스
- **거래 기록**: 각 거래의 상세 정보 저장
- **자본 추적**: 시간에 따른 자본 변화 추적
- **성과 지표**: 다양한 성과 지표 계산 메서드
- **시각화**: 수익률 곡선 및 성과 차트 생성

#### 9. 검증 및 테스트
- **수동 계산 검증**: 소규모 거래로 수동 계산과 비교
- **단위 테스트**: 각 계산 함수별 정확성 검증
- **경계 조건 테스트**: 극값, 0값, 음수값 처리 확인
- **성능 테스트**: 대용량 거래 데이터 처리 성능 측정
- **실제 거래 비교**: 실제 거래 결과와 백테스트 결과 비교

#### 10. 고급 계산 기법
- **모멘텀 효과**: 연속 수익/손실 시 자본 배분 조정
- **리스크 조정 수익률**: 변동성 대비 수익률 평가
- **VaR 계산**: 일정 확률 하에서 예상 최대 손실
- **상관관계 분석**: 여러 자산 간 수익률 상관관계
- **시장 상황별 분석**: 상승장/하락장/횡보장별 성과 분석

#### 11. 실제 적용 예시
- **초기 자본**: 1,000만원
- **거래 비용**: 매수/매도 각 0.05%
- **슬리피지**: 거래 금액의 0.02%
- **포지션 크기**: 보유 자본의 20%
- **거래 결과**: 수익률 5% 거래 시
  - 거래 금액: 200만원
  - 수수료: 2,000원 (매수) + 2,000원 (매도) = 4,000원
  - 슬리피지: 400원 (매수) + 400원 (매도) = 800원
  - 순 수익: 200만원 × 0.05 - 4,800원 = 95,200원

#### 12. 최적화 고려사항
- **수수료 최적화**: 거래 빈도와 수수료 부담의 균형
- **슬리피지 최소화**: 지정가 주문 활용, 유동성 높은 시간대 거래
- **복리 효과 극대화**: 일정 수준의 수익률 유지로 복리 효과 활용
- **리스크 관리**: 과도한 레버리지로 인한 손실 방지
- **세금 고려**: 한국의 암호화폐 거래세 반영 (향후 적용 시)
