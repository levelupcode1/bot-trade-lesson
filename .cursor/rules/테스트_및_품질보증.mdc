---
globs: tests/**/*.py,src/**/*.py
description: í…ŒìŠ¤íŠ¸ ë° í’ˆì§ˆë³´ì¦ ê°€ì´ë“œë¼ì¸
---

# í…ŒìŠ¤íŠ¸ ë° í’ˆì§ˆë³´ì¦ ê°€ì´ë“œë¼ì¸

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì „ëµ

### í…ŒìŠ¤íŠ¸ í”¼ë¼ë¯¸ë“œ
```
        E2E Tests (10%)
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚   ì‚¬ìš©ì ì‹œë‚˜ë¦¬ì˜¤   â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    Integration Tests (20%)
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚     ëª¨ë“ˆ ê°„ ì—°ë™ í…ŒìŠ¤íŠ¸    â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Unit Tests (70%)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      ê°œë³„ í•¨ìˆ˜/í´ë˜ìŠ¤ í…ŒìŠ¤íŠ¸  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### í…ŒìŠ¤íŠ¸ ìœ í˜•ë³„ ëª©í‘œ
- **Unit Tests (70%)**: ê°œë³„ í•¨ìˆ˜/í´ë˜ìŠ¤ì˜ ì •í™•ì„± ê²€ì¦
- **Integration Tests (20%)**: ëª¨ë“ˆ ê°„ ì—°ë™ ë° API í˜¸ì¶œ ê²€ì¦
- **E2E Tests (10%)**: ì „ì²´ ì‹œìŠ¤í…œ ì›Œí¬í”Œë¡œìš° ê²€ì¦

## ğŸ”§ í…ŒìŠ¤íŠ¸ í™˜ê²½ ì„¤ì •

### pytest ì„¤ì •
```python
# conftest.py
import pytest
import asyncio
from unittest.mock import Mock, AsyncMock
from src.trading_system import TradingSystem
from src.config.config_manager import ConfigManager

@pytest.fixture
def event_loop():
    """ì´ë²¤íŠ¸ ë£¨í”„ í”½ìŠ¤ì²˜"""
    loop = asyncio.new_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def mock_config():
    """ëª¨ì˜ ì„¤ì • í”½ìŠ¤ì²˜"""
    return {
        'trading': {
            'enabled': True,
            'symbols': ['KRW-BTC'],
            'max_positions': 5
        },
        'risk': {
            'max_position_size': 0.1,
            'daily_loss_limit': 0.02
        }
    }

@pytest.fixture
def mock_exchange_api():
    """ëª¨ì˜ ê±°ë˜ì†Œ API í”½ìŠ¤ì²˜"""
    api = Mock()
    api.get_price = AsyncMock(return_value=50000000)
    api.place_order = AsyncMock(return_value={'success': True, 'order_id': 'test_123'})
    api.cancel_order = AsyncMock(return_value={'success': True})
    return api

@pytest.fixture
def mock_telegram_bot():
    """ëª¨ì˜ í…”ë ˆê·¸ë¨ ë´‡ í”½ìŠ¤ì²˜"""
    bot = Mock()
    bot.send_message = AsyncMock(return_value=True)
    bot.send_trade_notification = AsyncMock(return_value=True)
    return bot

@pytest.fixture
def trading_system(mock_config, mock_exchange_api, mock_telegram_bot):
    """íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œ í”½ìŠ¤ì²˜"""
    system = TradingSystem(mock_config)
    system.exchange_api = mock_exchange_api
    system.telegram_bot = mock_telegram_bot
    return system
```

### í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±
```python
# tests/fixtures/test_data.py
import pandas as pd
from datetime import datetime, timedelta
from typing import List, Dict

class TestDataFactory:
    """í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„± íŒ©í† ë¦¬"""
    
    @staticmethod
    def create_price_data(symbol: str = "KRW-BTC", 
                         days: int = 30) -> List[Dict]:
        """ê°€ê²© ë°ì´í„° ìƒì„±"""
        base_price = 50000000
        data = []
        
        for i in range(days * 24):  # ì‹œê°„ë‹¹ ë°ì´í„°
            timestamp = datetime.now() - timedelta(hours=i)
            price = base_price + (i * 1000)  # ê°€ê²© ë³€ë™
            volume = 1000 + (i * 10)
            
            data.append({
                'symbol': symbol,
                'price': price,
                'volume': volume,
                'timestamp': timestamp,
                'change_rate': 0.01
            })
        
        return data
    
    @staticmethod
    def create_trade_data(symbol: str = "KRW-BTC") -> Dict:
        """ê±°ë˜ ë°ì´í„° ìƒì„±"""
        return {
            'order_id': 'test_order_123',
            'symbol': symbol,
            'side': 'BUY',
            'amount': 0.001,
            'price': 50000000,
            'status': 'FILLED',
            'strategy': 'volatility_breakout',
            'timestamp': datetime.now()
        }
    
    @staticmethod
    def create_technical_indicators() -> Dict:
        """ê¸°ìˆ ì  ì§€í‘œ ë°ì´í„° ìƒì„±"""
        return {
            'sma_5': 50100000,
            'sma_20': 50000000,
            'ema_12': 50050000,
            'ema_26': 49950000,
            'rsi': 65.5,
            'macd': 100000,
            'macd_signal': 95000,
            'bollinger_upper': 51000000,
            'bollinger_lower': 49000000,
            'atr': 500000
        }
```

## ğŸ”¬ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

### 1. ì „ëµ í´ë˜ìŠ¤ í…ŒìŠ¤íŠ¸
```python
# tests/unit/test_volatility_breakout_strategy.py
import pytest
from unittest.mock import Mock, patch
from src.strategy.volatility_breakout import VolatilityBreakoutStrategy
from tests.fixtures.test_data import TestDataFactory

class TestVolatilityBreakoutStrategy:
    """ë³€ë™ì„± ëŒíŒŒ ì „ëµ í…ŒìŠ¤íŠ¸"""
    
    def setup_method(self):
        """í…ŒìŠ¤íŠ¸ ì„¤ì •"""
        self.strategy = VolatilityBreakoutStrategy(
            k_value=0.7,
            stop_loss=-0.02,
            take_profit=0.05
        )
        self.test_data = TestDataFactory.create_price_data()
    
    def test_strategy_initialization(self):
        """ì „ëµ ì´ˆê¸°í™” í…ŒìŠ¤íŠ¸"""
        assert self.strategy.k_value == 0.7
        assert self.strategy.stop_loss == -0.02
        assert self.strategy.take_profit == 0.05
        assert self.strategy.is_active is False
    
    def test_generate_signal_buy(self):
        """ë§¤ìˆ˜ ì‹ í˜¸ ìƒì„± í…ŒìŠ¤íŠ¸"""
        # Given: ìƒìŠ¹ ì¶”ì„¸ ë°ì´í„°
        price_data = [100, 102, 101, 103, 105, 107, 106, 108, 110]
        
        # When
        signal = self.strategy.generate_signal(price_data)
        
        # Then
        assert signal in ["BUY", "SELL", "HOLD"]
    
    def test_generate_signal_sell(self):
        """ë§¤ë„ ì‹ í˜¸ ìƒì„± í…ŒìŠ¤íŠ¸"""
        # Given: í•˜ë½ ì¶”ì„¸ ë°ì´í„°
        price_data = [110, 108, 106, 104, 102, 100, 98, 96, 94]
        
        # When
        signal = self.strategy.generate_signal(price_data)
        
        # Then
        assert signal in ["BUY", "SELL", "HOLD"]
    
    def test_calculate_position_size(self):
        """í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° í…ŒìŠ¤íŠ¸"""
        # Given
        account_balance = 1000000  # 100ë§Œì›
        risk_percentage = 0.02  # 2%
        current_price = 50000000  # 5ì²œë§Œì›
        
        # When
        position_size = self.strategy.calculate_position_size(
            account_balance, risk_percentage, current_price
        )
        
        # Then
        expected_size = (account_balance * risk_percentage) / current_price
        assert position_size == expected_size
    
    def test_risk_management(self):
        """ë¦¬ìŠ¤í¬ ê´€ë¦¬ í…ŒìŠ¤íŠ¸"""
        # Given
        position = {
            'symbol': 'KRW-BTC',
            'entry_price': 50000000,
            'current_price': 49000000,  # 2% í•˜ë½
            'amount': 0.001
        }
        
        # When
        should_stop_loss = self.strategy.check_stop_loss(position)
        
        # Then
        assert should_stop_loss is True  # 2% ì†ì‹¤ë¡œ ì†ì ˆ ì¡°ê±´ ë§Œì¡±
    
    @patch('src.strategy.volatility_breakout.TechnicalAnalyzer')
    def test_technical_indicators_integration(self, mock_analyzer):
        """ê¸°ìˆ ì  ì§€í‘œ í†µí•© í…ŒìŠ¤íŠ¸"""
        # Given
        mock_analyzer.return_value.calculate_indicators.return_value = \
            TestDataFactory.create_technical_indicators()
        
        # When
        signal = self.strategy.generate_signal(self.test_data)
        
        # Then
        mock_analyzer.assert_called_once()
        assert signal in ["BUY", "SELL", "HOLD"]
```

### 2. ë¦¬ìŠ¤í¬ ê´€ë¦¬ì í…ŒìŠ¤íŠ¸
```python
# tests/unit/test_risk_manager.py
import pytest
from src.risk.risk_manager import RiskManager, RiskLimits, Position
from src.order.order_executor import Order, OrderSide, OrderType

class TestRiskManager:
    """ë¦¬ìŠ¤í¬ ê´€ë¦¬ì í…ŒìŠ¤íŠ¸"""
    
    def setup_method(self):
        """í…ŒìŠ¤íŠ¸ ì„¤ì •"""
        self.risk_limits = RiskLimits(
            max_position_size=0.1,
            daily_loss_limit=0.02,
            max_concurrent_positions=5
        )
        self.risk_manager = RiskManager(1000000, self.risk_limits)
    
    def test_daily_loss_limit_check(self):
        """ì¼ì¼ ì†ì‹¤ í•œë„ í™•ì¸ í…ŒìŠ¤íŠ¸"""
        # Given: 2.5% ì†ì‹¤ (í•œë„ ì´ˆê³¼)
        self.risk_manager.daily_pnl = -25000
        
        # When
        result = self.risk_manager._check_daily_loss_limit()
        
        # Then
        assert result is False
    
    def test_position_size_validation(self):
        """í¬ì§€ì…˜ í¬ê¸° ê²€ì¦ í…ŒìŠ¤íŠ¸"""
        # Given: 5ë§Œì› ì£¼ë¬¸ (5% í¬ì§€ì…˜)
        order = Order(
            id="test_order",
            symbol="KRW-BTC",
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            amount=0.001,
            price=50000000
        )
        
        # When
        result = self.risk_manager._check_position_size(order)
        
        # Then
        assert result is True  # 5%ëŠ” 10% í•œë„ ë‚´
    
    def test_concurrent_positions_limit(self):
        """ë™ì‹œ í¬ì§€ì…˜ ìˆ˜ í•œë„ í…ŒìŠ¤íŠ¸"""
        # Given: 5ê°œ í¬ì§€ì…˜ ìƒì„±
        for i in range(5):
            position = Position(
                symbol=f"KRW-COIN{i}",
                side="long",
                amount=0.001,
                entry_price=50000000,
                current_price=50000000,
                unrealized_pnl=0.0,
                created_at=datetime.now()
            )
            self.risk_manager.positions[f"position_{i}"] = position
        
        # When
        result = self.risk_manager._check_concurrent_positions()
        
        # Then
        assert result is False  # ìµœëŒ€ 5ê°œ ì´ˆê³¼
    
    def test_stop_loss_detection(self):
        """ì†ì ˆ ê°ì§€ í…ŒìŠ¤íŠ¸"""
        # Given: 3% ì†ì‹¤ í¬ì§€ì…˜
        position = Position(
            symbol="KRW-BTC",
            side="long",
            amount=0.001,
            entry_price=50000000,
            current_price=48500000,  # 3% í•˜ë½
            unrealized_pnl=-150000,
            created_at=datetime.now()
        )
        self.risk_manager.positions["test_position"] = position
        
        # When
        should_stop_loss = self.risk_manager.check_stop_loss("KRW-BTC", 48500000)
        
        # Then
        assert should_stop_loss is True  # 3% > 2% ì†ì ˆ í•œë„
    
    def test_take_profit_detection(self):
        """ìµì ˆ ê°ì§€ í…ŒìŠ¤íŠ¸"""
        # Given: 6% ìˆ˜ìµ í¬ì§€ì…˜
        position = Position(
            symbol="KRW-BTC",
            side="long",
            amount=0.001,
            entry_price=50000000,
            current_price=53000000,  # 6% ìƒìŠ¹
            unrealized_pnl=300000,
            created_at=datetime.now()
        )
        self.risk_manager.positions["test_position"] = position
        
        # When
        should_take_profit = self.risk_manager.check_take_profit("KRW-BTC", 53000000)
        
        # Then
        assert should_take_profit is True  # 6% > 5% ìµì ˆ í•œë„
```

### 3. ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ì í…ŒìŠ¤íŠ¸
```python
# tests/unit/test_database_manager.py
import pytest
import tempfile
import os
from src.database.database_manager import DatabaseManager
from tests.fixtures.test_data import TestDataFactory

class TestDatabaseManager:
    """ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ì í…ŒìŠ¤íŠ¸"""
    
    def setup_method(self):
        """í…ŒìŠ¤íŠ¸ ì„¤ì •"""
        self.temp_db = tempfile.NamedTemporaryFile(delete=False, suffix='.db')
        self.temp_db.close()
        self.db_manager = DatabaseManager(self.temp_db.name)
    
    def teardown_method(self):
        """í…ŒìŠ¤íŠ¸ ì •ë¦¬"""
        os.unlink(self.temp_db.name)
    
    def test_database_initialization(self):
        """ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” í…ŒìŠ¤íŠ¸"""
        # Given & When
        db_manager = DatabaseManager(":memory:")  # ë©”ëª¨ë¦¬ DB ì‚¬ìš©
        
        # Then
        assert db_manager is not None
    
    def test_save_price_data(self):
        """ê°€ê²© ë°ì´í„° ì €ì¥ í…ŒìŠ¤íŠ¸"""
        # Given
        price_data = {
            'symbol': 'KRW-BTC',
            'price': 50000000,
            'volume': 1000,
            'timestamp': datetime.now()
        }
        
        # When
        result = self.db_manager.save_price_data(price_data)
        
        # Then
        assert result is True
    
    def test_save_trade_data(self):
        """ê±°ë˜ ë°ì´í„° ì €ì¥ í…ŒìŠ¤íŠ¸"""
        # Given
        trade_data = TestDataFactory.create_trade_data()
        
        # When
        result = self.db_manager.save_trade(trade_data)
        
        # Then
        assert result is True
    
    def test_get_price_history(self):
        """ê°€ê²© íˆìŠ¤í† ë¦¬ ì¡°íšŒ í…ŒìŠ¤íŠ¸"""
        # Given: í…ŒìŠ¤íŠ¸ ë°ì´í„° ì €ì¥
        for i in range(10):
            price_data = {
                'symbol': 'KRW-BTC',
                'price': 50000000 + (i * 1000),
                'volume': 1000 + i,
                'timestamp': datetime.now()
            }
            self.db_manager.save_price_data(price_data)
        
        # When
        history = self.db_manager.get_price_history('KRW-BTC', days=1)
        
        # Then
        assert len(history) == 10
        assert all(item['symbol'] == 'KRW-BTC' for item in history)
    
    def test_get_trade_history(self):
        """ê±°ë˜ íˆìŠ¤í† ë¦¬ ì¡°íšŒ í…ŒìŠ¤íŠ¸"""
        # Given: í…ŒìŠ¤íŠ¸ ê±°ë˜ ë°ì´í„° ì €ì¥
        for i in range(5):
            trade_data = TestDataFactory.create_trade_data()
            trade_data['order_id'] = f'test_order_{i}'
            self.db_manager.save_trade(trade_data)
        
        # When
        trades = self.db_manager.get_trade_history('KRW-BTC', days=1)
        
        # Then
        assert len(trades) == 5
        assert all(trade['symbol'] == 'KRW-BTC' for trade in trades)
```

## ğŸ”— í†µí•© í…ŒìŠ¤íŠ¸

### 1. API ì—°ë™ í…ŒìŠ¤íŠ¸
```python
# tests/integration/test_api_integration.py
import pytest
import aiohttp
from unittest.mock import patch, AsyncMock
from src.exchange.upbit_api import UpbitAPI

class TestUpbitAPIIntegration:
    """ì—…ë¹„íŠ¸ API í†µí•© í…ŒìŠ¤íŠ¸"""
    
    @pytest.fixture
    def upbit_api(self):
        """ì—…ë¹„íŠ¸ API í”½ìŠ¤ì²˜"""
        return UpbitAPI()
    
    @pytest.mark.asyncio
    async def test_get_price_data(self, upbit_api):
        """ê°€ê²© ë°ì´í„° ì¡°íšŒ í…ŒìŠ¤íŠ¸"""
        # Given
        symbol = "KRW-BTC"
        
        # When
        with patch('aiohttp.ClientSession.get') as mock_get:
            mock_response = AsyncMock()
            mock_response.json.return_value = [{
                'market': symbol,
                'trade_price': 50000000,
                'trade_volume': 1.0,
                'change_rate': 0.01
            }]
            mock_get.return_value.__aenter__.return_value = mock_response
            
            result = await upbit_api.get_price_data(symbol)
        
        # Then
        assert result is not None
        assert 'price' in result
        assert result['price'] == 50000000
    
    @pytest.mark.asyncio
    async def test_place_order(self, upbit_api):
        """ì£¼ë¬¸ ì‹¤í–‰ í…ŒìŠ¤íŠ¸"""
        # Given
        order_params = {
            'market': 'KRW-BTC',
            'side': 'bid',
            'volume': '0.001',
            'price': '50000000',
            'ord_type': 'limit'
        }
        
        # When
        with patch('aiohttp.ClientSession.post') as mock_post:
            mock_response = AsyncMock()
            mock_response.json.return_value = {
                'uuid': 'test_order_123',
                'state': 'wait'
            }
            mock_post.return_value.__aenter__.return_value = mock_response
            
            result = await upbit_api.place_order(order_params)
        
        # Then
        assert result is not None
        assert 'uuid' in result
        assert result['uuid'] == 'test_order_123'
    
    @pytest.mark.asyncio
    async def test_websocket_connection(self, upbit_api):
        """WebSocket ì—°ê²° í…ŒìŠ¤íŠ¸"""
        # Given
        symbols = ['KRW-BTC', 'KRW-ETH']
        
        # When
        with patch('websockets.connect') as mock_connect:
            mock_ws = AsyncMock()
            mock_connect.return_value.__aenter__.return_value = mock_ws
            
            await upbit_api.start_websocket(symbols, callback=AsyncMock())
        
        # Then
        mock_connect.assert_called_once()
```

### 2. í…”ë ˆê·¸ë¨ ë´‡ í†µí•© í…ŒìŠ¤íŠ¸
```python
# tests/integration/test_telegram_integration.py
import pytest
from unittest.mock import patch, AsyncMock
from src.notification.telegram_bot import TelegramBot

class TestTelegramBotIntegration:
    """í…”ë ˆê·¸ë¨ ë´‡ í†µí•© í…ŒìŠ¤íŠ¸"""
    
    @pytest.fixture
    def telegram_bot(self):
        """í…”ë ˆê·¸ë¨ ë´‡ í”½ìŠ¤ì²˜"""
        return TelegramBot("test_token", "test_chat_id")
    
    @pytest.mark.asyncio
    async def test_send_message(self, telegram_bot):
        """ë©”ì‹œì§€ ì „ì†¡ í…ŒìŠ¤íŠ¸"""
        # Given
        message = "í…ŒìŠ¤íŠ¸ ë©”ì‹œì§€"
        
        # When
        with patch('aiohttp.ClientSession.post') as mock_post:
            mock_response = AsyncMock()
            mock_response.status = 200
            mock_post.return_value.__aenter__.return_value = mock_response
            
            result = await telegram_bot.send_message(message)
        
        # Then
        assert result is True
    
    @pytest.mark.asyncio
    async def test_send_trade_notification(self, telegram_bot):
        """ê±°ë˜ ì•Œë¦¼ ì „ì†¡ í…ŒìŠ¤íŠ¸"""
        # Given
        trade_data = {
            'symbol': 'KRW-BTC',
            'action': 'BUY',
            'amount': 0.001,
            'price': 50000000,
            'timestamp': datetime.now(),
            'strategy': 'volatility_breakout'
        }
        
        # When
        with patch('aiohttp.ClientSession.post') as mock_post:
            mock_response = AsyncMock()
            mock_response.status = 200
            mock_post.return_value.__aenter__.return_value = mock_response
            
            result = await telegram_bot.send_trade_notification(trade_data)
        
        # Then
        assert result is True
    
    @pytest.mark.asyncio
    async def test_send_performance_report(self, telegram_bot):
        """ì„±ê³¼ ë¦¬í¬íŠ¸ ì „ì†¡ í…ŒìŠ¤íŠ¸"""
        # Given
        report_data = {
            'total_return': 5.5,
            'win_rate': 65.0,
            'max_drawdown': 2.1,
            'sharpe_ratio': 1.8,
            'period': '1ê°œì›”'
        }
        
        # When
        with patch('aiohttp.ClientSession.post') as mock_post:
            mock_response = AsyncMock()
            mock_response.status = 200
            mock_post.return_value.__aenter__.return_value = mock_response
            
            result = await telegram_bot.send_performance_report(report_data)
        
        # Then
        assert result is True
```

## ğŸ¯ E2E í…ŒìŠ¤íŠ¸

### 1. ì „ì²´ ì‹œìŠ¤í…œ ì›Œí¬í”Œë¡œìš° í…ŒìŠ¤íŠ¸
```python
# tests/e2e/test_full_system_workflow.py
import pytest
import asyncio
from unittest.mock import Mock, AsyncMock, patch
from src.trading_system import TradingSystem
from tests.fixtures.test_data import TestDataFactory

class TestFullSystemWorkflow:
    """ì „ì²´ ì‹œìŠ¤í…œ ì›Œí¬í”Œë¡œìš° í…ŒìŠ¤íŠ¸"""
    
    @pytest.fixture
    def system_config(self):
        """ì‹œìŠ¤í…œ ì„¤ì • í”½ìŠ¤ì²˜"""
        return {
            'trading': {
                'enabled': True,
                'symbols': ['KRW-BTC'],
                'max_positions': 2
            },
            'risk': {
                'max_position_size': 0.1,
                'daily_loss_limit': 0.02,
                'stop_loss': 0.02,
                'take_profit': 0.05
            },
            'strategies': {
                'volatility_breakout': {
                    'enabled': True,
                    'k_value': 0.7
                }
            },
            'notification': {
                'telegram': {
                    'enabled': True,
                    'bot_token': 'test_token',
                    'chat_id': 'test_chat_id'
                }
            }
        }
    
    @pytest.mark.asyncio
    async def test_complete_trading_cycle(self, system_config):
        """ì™„ì „í•œ ê±°ë˜ ì‚¬ì´í´ í…ŒìŠ¤íŠ¸"""
        # Given
        with patch.multiple(
            'src.exchange.upbit_api.UpbitAPI',
            get_price=AsyncMock(return_value=50000000),
            place_order=AsyncMock(return_value={'success': True, 'order_id': 'test_123'}),
            get_order_status=AsyncMock(return_value={'status': 'filled'})
        ), patch.multiple(
            'src.notification.telegram_bot.TelegramBot',
            send_message=AsyncMock(return_value=True),
            send_trade_notification=AsyncMock(return_value=True)
        ):
            system = TradingSystem(system_config)
            
            # When: ì‹œìŠ¤í…œ ì‹œì‘
            await system.start()
            
            # ê°€ê²© ë°ì´í„° ì‹œë®¬ë ˆì´ì…˜
            price_data = TestDataFactory.create_price_data()
            for data in price_data[:10]:  # 10ê°œ ë°ì´í„°ë§Œ ì‚¬ìš©
                await system.price_monitor.process_price_data(data)
            
            # ê±°ë˜ ì‹ í˜¸ ìƒì„± ëŒ€ê¸°
            await asyncio.sleep(0.1)
            
            # When: ì‹œìŠ¤í…œ ì¤‘ì§€
            await system.stop()
        
        # Then
        assert system.is_running is False
        # ì¶”ê°€ ê²€ì¦ ë¡œì§...
    
    @pytest.mark.asyncio
    async def test_error_recovery_workflow(self, system_config):
        """ì˜¤ë¥˜ ë³µêµ¬ ì›Œí¬í”Œë¡œìš° í…ŒìŠ¤íŠ¸"""
        # Given
        with patch('src.exchange.upbit_api.UpbitAPI.get_price') as mock_get_price:
            # ì²« ë²ˆì§¸ í˜¸ì¶œì—ì„œ ì˜¤ë¥˜ ë°œìƒ, ë‘ ë²ˆì§¸ í˜¸ì¶œì—ì„œ ì„±ê³µ
            mock_get_price.side_effect = [
                Exception("API ì˜¤ë¥˜"),
                AsyncMock(return_value=50000000)
            ]
            
            system = TradingSystem(system_config)
            
            # When: ì˜¤ë¥˜ ë°œìƒ í›„ ë³µêµ¬
            await system.start()
            await asyncio.sleep(0.1)  # ì˜¤ë¥˜ ì²˜ë¦¬ ëŒ€ê¸°
            await system.stop()
        
        # Then
        # ì˜¤ë¥˜ ë³µêµ¬ ê²€ì¦ ë¡œì§...
        assert mock_get_price.call_count >= 2
    
    @pytest.mark.asyncio
    async def test_risk_management_workflow(self, system_config):
        """ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì›Œí¬í”Œë¡œìš° í…ŒìŠ¤íŠ¸"""
        # Given: ì†ì‹¤ í•œë„ ì´ˆê³¼ ì‹œë‚˜ë¦¬ì˜¤
        system_config['risk']['daily_loss_limit'] = 0.01  # 1% í•œë„
        
        with patch.multiple(
            'src.exchange.upbit_api.UpbitAPI',
            get_price=AsyncMock(return_value=50000000),
            place_order=AsyncMock(return_value={'success': True, 'order_id': 'test_123'})
        ):
            system = TradingSystem(system_config)
            await system.start()
            
            # When: ì†ì‹¤ í•œë„ ì´ˆê³¼ ì‹œë®¬ë ˆì´ì…˜
            system.risk_manager.daily_pnl = -15000  # 1.5% ì†ì‹¤
            
            # ê±°ë˜ ì‹œë„
            order_data = {
                'symbol': 'KRW-BTC',
                'side': 'BUY',
                'amount': 0.001,
                'price': 50000000
            }
            
            result = await system.order_executor.execute_order(order_data)
            
            await system.stop()
        
        # Then
        assert result['status'] == 'REJECTED'  # ë¦¬ìŠ¤í¬ í•œë„ ì´ˆê³¼ë¡œ ê±°ë¶€
```

## ğŸ“Š ì„±ëŠ¥ í…ŒìŠ¤íŠ¸

### 1. ë¶€í•˜ í…ŒìŠ¤íŠ¸
```python
# tests/performance/test_load_performance.py
import pytest
import asyncio
import time
from concurrent.futures import ThreadPoolExecutor
from src.trading_system import TradingSystem

class TestLoadPerformance:
    """ë¶€í•˜ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"""
    
    @pytest.mark.asyncio
    async def test_concurrent_price_updates(self):
        """ë™ì‹œ ê°€ê²© ì—…ë°ì´íŠ¸ í…ŒìŠ¤íŠ¸"""
        # Given
        system = TradingSystem(self.get_test_config())
        await system.start()
        
        # When: 100ê°œ ë™ì‹œ ê°€ê²© ì—…ë°ì´íŠ¸
        start_time = time.time()
        
        tasks = []
        for i in range(100):
            price_data = {
                'symbol': 'KRW-BTC',
                'price': 50000000 + i,
                'volume': 1000,
                'timestamp': datetime.now()
            }
            task = asyncio.create_task(
                system.price_monitor.process_price_data(price_data)
            )
            tasks.append(task)
        
        await asyncio.gather(*tasks)
        
        end_time = time.time()
        processing_time = end_time - start_time
        
        await system.stop()
        
        # Then: 1ì´ˆ ì´ë‚´ ì²˜ë¦¬
        assert processing_time < 1.0
    
    @pytest.mark.asyncio
    async def test_memory_usage_under_load(self):
        """ë¶€í•˜ ìƒíƒœì—ì„œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ í…ŒìŠ¤íŠ¸"""
        import psutil
        import os
        
        # Given
        process = psutil.Process(os.getpid())
        initial_memory = process.memory_info().rss
        
        system = TradingSystem(self.get_test_config())
        await system.start()
        
        # When: 1000ê°œ ê°€ê²© ë°ì´í„° ì²˜ë¦¬
        for i in range(1000):
            price_data = {
                'symbol': 'KRW-BTC',
                'price': 50000000 + i,
                'volume': 1000,
                'timestamp': datetime.now()
            }
            await system.price_monitor.process_price_data(price_data)
        
        current_memory = process.memory_info().rss
        memory_increase = current_memory - initial_memory
        
        await system.stop()
        
        # Then: ë©”ëª¨ë¦¬ ì¦ê°€ëŸ‰ì´ 100MB ì´í•˜
        assert memory_increase < 100 * 1024 * 1024  # 100MB
    
    def test_database_performance(self):
        """ë°ì´í„°ë² ì´ìŠ¤ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"""
        # Given
        db_manager = DatabaseManager(":memory:")
        
        # When: 1000ê°œ ë ˆì½”ë“œ ì‚½ì…
        start_time = time.time()
        
        for i in range(1000):
            price_data = {
                'symbol': 'KRW-BTC',
                'price': 50000000 + i,
                'volume': 1000,
                'timestamp': datetime.now()
            }
            db_manager.save_price_data(price_data)
        
        end_time = time.time()
        insert_time = end_time - start_time
        
        # Then: 1000ê°œ ë ˆì½”ë“œê°€ 1ì´ˆ ì´ë‚´ ì‚½ì…
        assert insert_time < 1.0
        assert insert_time / 1000 < 0.001  # ë ˆì½”ë“œë‹¹ 1ms ì´ë‚´
```

## ğŸ” ì½”ë“œ ì»¤ë²„ë¦¬ì§€

### ì»¤ë²„ë¦¬ì§€ ì„¤ì •
```python
# pytest.ini
[tool:pytest]
addopts = --cov=src --cov-report=html --cov-report=term-missing --cov-fail-under=80
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
```

### ì»¤ë²„ë¦¬ì§€ ëª©í‘œ
- **ì „ì²´ ì»¤ë²„ë¦¬ì§€**: 80% ì´ìƒ
- **í•µì‹¬ ëª¨ë“ˆ**: 90% ì´ìƒ (trading_system, risk_manager, order_executor)
- **ìœ í‹¸ë¦¬í‹° ëª¨ë“ˆ**: 70% ì´ìƒ

## ğŸš¨ í’ˆì§ˆ ê²Œì´íŠ¸

### 1. ì½”ë“œ í’ˆì§ˆ ê²€ì‚¬
```bash
# ì½”ë“œ ìŠ¤íƒ€ì¼ ê²€ì‚¬
flake8 src/ --max-line-length=88 --extend-ignore=E203,W503

# íƒ€ì… ê²€ì‚¬
mypy src/ --strict

# ë³´ì•ˆ ê²€ì‚¬
bandit -r src/ -f json -o security_report.json
```

### 2. í…ŒìŠ¤íŠ¸ ì‹¤í–‰
```bash
# ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
pytest tests/unit/ -v --cov=src

# í†µí•© í…ŒìŠ¤íŠ¸
pytest tests/integration/ -v

# E2E í…ŒìŠ¤íŠ¸
pytest tests/e2e/ -v

# ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
pytest tests/performance/ -v
```

### 3. í’ˆì§ˆ ê²Œì´íŠ¸ ì¡°ê±´
- [ ] ëª¨ë“  í…ŒìŠ¤íŠ¸ í†µê³¼ (100%)
- [ ] ì½”ë“œ ì»¤ë²„ë¦¬ì§€ 80% ì´ìƒ
- [ ] flake8 ì˜¤ë¥˜ 0ê°œ
- [ ] mypy ì˜¤ë¥˜ 0ê°œ
- [ ] bandit ë³´ì•ˆ ì´ìŠˆ 0ê°œ
- [ ] ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ í†µê³¼

## ğŸ“‹ í…ŒìŠ¤íŠ¸ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ê°œë°œ ë‹¨ê³„ë³„ í…ŒìŠ¤íŠ¸
- [ ] **Phase 1**: ê¸°ë³¸ í´ë˜ìŠ¤ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
- [ ] **Phase 2**: API ì—°ë™ í†µí•© í…ŒìŠ¤íŠ¸
- [ ] **Phase 3**: ì „ëµ ë¡œì§ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
- [ ] **Phase 4**: ë¦¬ìŠ¤í¬ ê´€ë¦¬ í†µí•© í…ŒìŠ¤íŠ¸
- [ ] **Phase 5**: ì›¹ ì¸í„°í˜ì´ìŠ¤ E2E í…ŒìŠ¤íŠ¸
- [ ] **Phase 6**: ì „ì²´ ì‹œìŠ¤í…œ E2E í…ŒìŠ¤íŠ¸

### ë¦´ë¦¬ì¦ˆ ì „ í•„ìˆ˜ í…ŒìŠ¤íŠ¸
- [ ] ëª¨ë“  ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ í†µê³¼
- [ ] ëª¨ë“  í†µí•© í…ŒìŠ¤íŠ¸ í†µê³¼
- [ ] ëª¨ë“  E2E í…ŒìŠ¤íŠ¸ í†µê³¼
- [ ] ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ í†µê³¼
- [ ] ë³´ì•ˆ í…ŒìŠ¤íŠ¸ í†µê³¼
- [ ] ì½”ë“œ ì»¤ë²„ë¦¬ì§€ ëª©í‘œ ë‹¬ì„±

ì´ í…ŒìŠ¤íŠ¸ ë° í’ˆì§ˆë³´ì¦ ê°€ì´ë“œë¼ì¸ì€ PRD.mdì˜ ìš”êµ¬ì‚¬í•­ì„ ê¸°ë°˜ìœ¼ë¡œ ì²´ê³„ì ì¸ í…ŒìŠ¤íŠ¸ ì „ëµì„ ì œê³µí•©ë‹ˆë‹¤. ê° í…ŒìŠ¤íŠ¸ ìœ í˜•ë³„ë¡œ êµ¬ì²´ì ì¸ êµ¬í˜„ ë°©ë²•ê³¼ ê²€ì¦ ê¸°ì¤€ì„ ì œì‹œí•˜ì—¬ ë†’ì€ í’ˆì§ˆì˜ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•  ìˆ˜ ìˆë„ë¡ ë„ì™€ì¤ë‹ˆë‹¤.