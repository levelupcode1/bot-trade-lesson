---
globs: tests/**/*.py,src/**/*.py
description: 테스트 및 품질보증 가이드라인
---

# 테스트 및 품질보증 가이드라인

## 🧪 테스트 전략

### 테스트 피라미드
```
        E2E Tests (10%)
       ┌─────────────────┐
      │   사용자 시나리오   │
     └─────────────────┘
    Integration Tests (20%)
   ┌─────────────────────────┐
  │     모듈 간 연동 테스트    │
 └─────────────────────────┘
Unit Tests (70%)
┌─────────────────────────────┐
│      개별 함수/클래스 테스트  │
└─────────────────────────────┘
```

### 테스트 유형별 목표
- **Unit Tests (70%)**: 개별 함수/클래스의 정확성 검증
- **Integration Tests (20%)**: 모듈 간 연동 및 API 호출 검증
- **E2E Tests (10%)**: 전체 시스템 워크플로우 검증

## 🔧 테스트 환경 설정

### pytest 설정
```python
# conftest.py
import pytest
import asyncio
from unittest.mock import Mock, AsyncMock
from src.trading_system import TradingSystem
from src.config.config_manager import ConfigManager

@pytest.fixture
def event_loop():
    """이벤트 루프 픽스처"""
    loop = asyncio.new_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def mock_config():
    """모의 설정 픽스처"""
    return {
        'trading': {
            'enabled': True,
            'symbols': ['KRW-BTC'],
            'max_positions': 5
        },
        'risk': {
            'max_position_size': 0.1,
            'daily_loss_limit': 0.02
        }
    }

@pytest.fixture
def mock_exchange_api():
    """모의 거래소 API 픽스처"""
    api = Mock()
    api.get_price = AsyncMock(return_value=50000000)
    api.place_order = AsyncMock(return_value={'success': True, 'order_id': 'test_123'})
    api.cancel_order = AsyncMock(return_value={'success': True})
    return api

@pytest.fixture
def mock_telegram_bot():
    """모의 텔레그램 봇 픽스처"""
    bot = Mock()
    bot.send_message = AsyncMock(return_value=True)
    bot.send_trade_notification = AsyncMock(return_value=True)
    return bot

@pytest.fixture
def trading_system(mock_config, mock_exchange_api, mock_telegram_bot):
    """트레이딩 시스템 픽스처"""
    system = TradingSystem(mock_config)
    system.exchange_api = mock_exchange_api
    system.telegram_bot = mock_telegram_bot
    return system
```

### 테스트 데이터 생성
```python
# tests/fixtures/test_data.py
import pandas as pd
from datetime import datetime, timedelta
from typing import List, Dict

class TestDataFactory:
    """테스트 데이터 생성 팩토리"""
    
    @staticmethod
    def create_price_data(symbol: str = "KRW-BTC", 
                         days: int = 30) -> List[Dict]:
        """가격 데이터 생성"""
        base_price = 50000000
        data = []
        
        for i in range(days * 24):  # 시간당 데이터
            timestamp = datetime.now() - timedelta(hours=i)
            price = base_price + (i * 1000)  # 가격 변동
            volume = 1000 + (i * 10)
            
            data.append({
                'symbol': symbol,
                'price': price,
                'volume': volume,
                'timestamp': timestamp,
                'change_rate': 0.01
            })
        
        return data
    
    @staticmethod
    def create_trade_data(symbol: str = "KRW-BTC") -> Dict:
        """거래 데이터 생성"""
        return {
            'order_id': 'test_order_123',
            'symbol': symbol,
            'side': 'BUY',
            'amount': 0.001,
            'price': 50000000,
            'status': 'FILLED',
            'strategy': 'volatility_breakout',
            'timestamp': datetime.now()
        }
    
    @staticmethod
    def create_technical_indicators() -> Dict:
        """기술적 지표 데이터 생성"""
        return {
            'sma_5': 50100000,
            'sma_20': 50000000,
            'ema_12': 50050000,
            'ema_26': 49950000,
            'rsi': 65.5,
            'macd': 100000,
            'macd_signal': 95000,
            'bollinger_upper': 51000000,
            'bollinger_lower': 49000000,
            'atr': 500000
        }
```

## 🔬 단위 테스트

### 1. 전략 클래스 테스트
```python
# tests/unit/test_volatility_breakout_strategy.py
import pytest
from unittest.mock import Mock, patch
from src.strategy.volatility_breakout import VolatilityBreakoutStrategy
from tests.fixtures.test_data import TestDataFactory

class TestVolatilityBreakoutStrategy:
    """변동성 돌파 전략 테스트"""
    
    def setup_method(self):
        """테스트 설정"""
        self.strategy = VolatilityBreakoutStrategy(
            k_value=0.7,
            stop_loss=-0.02,
            take_profit=0.05
        )
        self.test_data = TestDataFactory.create_price_data()
    
    def test_strategy_initialization(self):
        """전략 초기화 테스트"""
        assert self.strategy.k_value == 0.7
        assert self.strategy.stop_loss == -0.02
        assert self.strategy.take_profit == 0.05
        assert self.strategy.is_active is False
    
    def test_generate_signal_buy(self):
        """매수 신호 생성 테스트"""
        # Given: 상승 추세 데이터
        price_data = [100, 102, 101, 103, 105, 107, 106, 108, 110]
        
        # When
        signal = self.strategy.generate_signal(price_data)
        
        # Then
        assert signal in ["BUY", "SELL", "HOLD"]
    
    def test_generate_signal_sell(self):
        """매도 신호 생성 테스트"""
        # Given: 하락 추세 데이터
        price_data = [110, 108, 106, 104, 102, 100, 98, 96, 94]
        
        # When
        signal = self.strategy.generate_signal(price_data)
        
        # Then
        assert signal in ["BUY", "SELL", "HOLD"]
    
    def test_calculate_position_size(self):
        """포지션 크기 계산 테스트"""
        # Given
        account_balance = 1000000  # 100만원
        risk_percentage = 0.02  # 2%
        current_price = 50000000  # 5천만원
        
        # When
        position_size = self.strategy.calculate_position_size(
            account_balance, risk_percentage, current_price
        )
        
        # Then
        expected_size = (account_balance * risk_percentage) / current_price
        assert position_size == expected_size
    
    def test_risk_management(self):
        """리스크 관리 테스트"""
        # Given
        position = {
            'symbol': 'KRW-BTC',
            'entry_price': 50000000,
            'current_price': 49000000,  # 2% 하락
            'amount': 0.001
        }
        
        # When
        should_stop_loss = self.strategy.check_stop_loss(position)
        
        # Then
        assert should_stop_loss is True  # 2% 손실로 손절 조건 만족
    
    @patch('src.strategy.volatility_breakout.TechnicalAnalyzer')
    def test_technical_indicators_integration(self, mock_analyzer):
        """기술적 지표 통합 테스트"""
        # Given
        mock_analyzer.return_value.calculate_indicators.return_value = \
            TestDataFactory.create_technical_indicators()
        
        # When
        signal = self.strategy.generate_signal(self.test_data)
        
        # Then
        mock_analyzer.assert_called_once()
        assert signal in ["BUY", "SELL", "HOLD"]
```

### 2. 리스크 관리자 테스트
```python
# tests/unit/test_risk_manager.py
import pytest
from src.risk.risk_manager import RiskManager, RiskLimits, Position
from src.order.order_executor import Order, OrderSide, OrderType

class TestRiskManager:
    """리스크 관리자 테스트"""
    
    def setup_method(self):
        """테스트 설정"""
        self.risk_limits = RiskLimits(
            max_position_size=0.1,
            daily_loss_limit=0.02,
            max_concurrent_positions=5
        )
        self.risk_manager = RiskManager(1000000, self.risk_limits)
    
    def test_daily_loss_limit_check(self):
        """일일 손실 한도 확인 테스트"""
        # Given: 2.5% 손실 (한도 초과)
        self.risk_manager.daily_pnl = -25000
        
        # When
        result = self.risk_manager._check_daily_loss_limit()
        
        # Then
        assert result is False
    
    def test_position_size_validation(self):
        """포지션 크기 검증 테스트"""
        # Given: 5만원 주문 (5% 포지션)
        order = Order(
            id="test_order",
            symbol="KRW-BTC",
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            amount=0.001,
            price=50000000
        )
        
        # When
        result = self.risk_manager._check_position_size(order)
        
        # Then
        assert result is True  # 5%는 10% 한도 내
    
    def test_concurrent_positions_limit(self):
        """동시 포지션 수 한도 테스트"""
        # Given: 5개 포지션 생성
        for i in range(5):
            position = Position(
                symbol=f"KRW-COIN{i}",
                side="long",
                amount=0.001,
                entry_price=50000000,
                current_price=50000000,
                unrealized_pnl=0.0,
                created_at=datetime.now()
            )
            self.risk_manager.positions[f"position_{i}"] = position
        
        # When
        result = self.risk_manager._check_concurrent_positions()
        
        # Then
        assert result is False  # 최대 5개 초과
    
    def test_stop_loss_detection(self):
        """손절 감지 테스트"""
        # Given: 3% 손실 포지션
        position = Position(
            symbol="KRW-BTC",
            side="long",
            amount=0.001,
            entry_price=50000000,
            current_price=48500000,  # 3% 하락
            unrealized_pnl=-150000,
            created_at=datetime.now()
        )
        self.risk_manager.positions["test_position"] = position
        
        # When
        should_stop_loss = self.risk_manager.check_stop_loss("KRW-BTC", 48500000)
        
        # Then
        assert should_stop_loss is True  # 3% > 2% 손절 한도
    
    def test_take_profit_detection(self):
        """익절 감지 테스트"""
        # Given: 6% 수익 포지션
        position = Position(
            symbol="KRW-BTC",
            side="long",
            amount=0.001,
            entry_price=50000000,
            current_price=53000000,  # 6% 상승
            unrealized_pnl=300000,
            created_at=datetime.now()
        )
        self.risk_manager.positions["test_position"] = position
        
        # When
        should_take_profit = self.risk_manager.check_take_profit("KRW-BTC", 53000000)
        
        # Then
        assert should_take_profit is True  # 6% > 5% 익절 한도
```

### 3. 데이터베이스 관리자 테스트
```python
# tests/unit/test_database_manager.py
import pytest
import tempfile
import os
from src.database.database_manager import DatabaseManager
from tests.fixtures.test_data import TestDataFactory

class TestDatabaseManager:
    """데이터베이스 관리자 테스트"""
    
    def setup_method(self):
        """테스트 설정"""
        self.temp_db = tempfile.NamedTemporaryFile(delete=False, suffix='.db')
        self.temp_db.close()
        self.db_manager = DatabaseManager(self.temp_db.name)
    
    def teardown_method(self):
        """테스트 정리"""
        os.unlink(self.temp_db.name)
    
    def test_database_initialization(self):
        """데이터베이스 초기화 테스트"""
        # Given & When
        db_manager = DatabaseManager(":memory:")  # 메모리 DB 사용
        
        # Then
        assert db_manager is not None
    
    def test_save_price_data(self):
        """가격 데이터 저장 테스트"""
        # Given
        price_data = {
            'symbol': 'KRW-BTC',
            'price': 50000000,
            'volume': 1000,
            'timestamp': datetime.now()
        }
        
        # When
        result = self.db_manager.save_price_data(price_data)
        
        # Then
        assert result is True
    
    def test_save_trade_data(self):
        """거래 데이터 저장 테스트"""
        # Given
        trade_data = TestDataFactory.create_trade_data()
        
        # When
        result = self.db_manager.save_trade(trade_data)
        
        # Then
        assert result is True
    
    def test_get_price_history(self):
        """가격 히스토리 조회 테스트"""
        # Given: 테스트 데이터 저장
        for i in range(10):
            price_data = {
                'symbol': 'KRW-BTC',
                'price': 50000000 + (i * 1000),
                'volume': 1000 + i,
                'timestamp': datetime.now()
            }
            self.db_manager.save_price_data(price_data)
        
        # When
        history = self.db_manager.get_price_history('KRW-BTC', days=1)
        
        # Then
        assert len(history) == 10
        assert all(item['symbol'] == 'KRW-BTC' for item in history)
    
    def test_get_trade_history(self):
        """거래 히스토리 조회 테스트"""
        # Given: 테스트 거래 데이터 저장
        for i in range(5):
            trade_data = TestDataFactory.create_trade_data()
            trade_data['order_id'] = f'test_order_{i}'
            self.db_manager.save_trade(trade_data)
        
        # When
        trades = self.db_manager.get_trade_history('KRW-BTC', days=1)
        
        # Then
        assert len(trades) == 5
        assert all(trade['symbol'] == 'KRW-BTC' for trade in trades)
```

## 🔗 통합 테스트

### 1. API 연동 테스트
```python
# tests/integration/test_api_integration.py
import pytest
import aiohttp
from unittest.mock import patch, AsyncMock
from src.exchange.upbit_api import UpbitAPI

class TestUpbitAPIIntegration:
    """업비트 API 통합 테스트"""
    
    @pytest.fixture
    def upbit_api(self):
        """업비트 API 픽스처"""
        return UpbitAPI()
    
    @pytest.mark.asyncio
    async def test_get_price_data(self, upbit_api):
        """가격 데이터 조회 테스트"""
        # Given
        symbol = "KRW-BTC"
        
        # When
        with patch('aiohttp.ClientSession.get') as mock_get:
            mock_response = AsyncMock()
            mock_response.json.return_value = [{
                'market': symbol,
                'trade_price': 50000000,
                'trade_volume': 1.0,
                'change_rate': 0.01
            }]
            mock_get.return_value.__aenter__.return_value = mock_response
            
            result = await upbit_api.get_price_data(symbol)
        
        # Then
        assert result is not None
        assert 'price' in result
        assert result['price'] == 50000000
    
    @pytest.mark.asyncio
    async def test_place_order(self, upbit_api):
        """주문 실행 테스트"""
        # Given
        order_params = {
            'market': 'KRW-BTC',
            'side': 'bid',
            'volume': '0.001',
            'price': '50000000',
            'ord_type': 'limit'
        }
        
        # When
        with patch('aiohttp.ClientSession.post') as mock_post:
            mock_response = AsyncMock()
            mock_response.json.return_value = {
                'uuid': 'test_order_123',
                'state': 'wait'
            }
            mock_post.return_value.__aenter__.return_value = mock_response
            
            result = await upbit_api.place_order(order_params)
        
        # Then
        assert result is not None
        assert 'uuid' in result
        assert result['uuid'] == 'test_order_123'
    
    @pytest.mark.asyncio
    async def test_websocket_connection(self, upbit_api):
        """WebSocket 연결 테스트"""
        # Given
        symbols = ['KRW-BTC', 'KRW-ETH']
        
        # When
        with patch('websockets.connect') as mock_connect:
            mock_ws = AsyncMock()
            mock_connect.return_value.__aenter__.return_value = mock_ws
            
            await upbit_api.start_websocket(symbols, callback=AsyncMock())
        
        # Then
        mock_connect.assert_called_once()
```

### 2. 텔레그램 봇 통합 테스트
```python
# tests/integration/test_telegram_integration.py
import pytest
from unittest.mock import patch, AsyncMock
from src.notification.telegram_bot import TelegramBot

class TestTelegramBotIntegration:
    """텔레그램 봇 통합 테스트"""
    
    @pytest.fixture
    def telegram_bot(self):
        """텔레그램 봇 픽스처"""
        return TelegramBot("test_token", "test_chat_id")
    
    @pytest.mark.asyncio
    async def test_send_message(self, telegram_bot):
        """메시지 전송 테스트"""
        # Given
        message = "테스트 메시지"
        
        # When
        with patch('aiohttp.ClientSession.post') as mock_post:
            mock_response = AsyncMock()
            mock_response.status = 200
            mock_post.return_value.__aenter__.return_value = mock_response
            
            result = await telegram_bot.send_message(message)
        
        # Then
        assert result is True
    
    @pytest.mark.asyncio
    async def test_send_trade_notification(self, telegram_bot):
        """거래 알림 전송 테스트"""
        # Given
        trade_data = {
            'symbol': 'KRW-BTC',
            'action': 'BUY',
            'amount': 0.001,
            'price': 50000000,
            'timestamp': datetime.now(),
            'strategy': 'volatility_breakout'
        }
        
        # When
        with patch('aiohttp.ClientSession.post') as mock_post:
            mock_response = AsyncMock()
            mock_response.status = 200
            mock_post.return_value.__aenter__.return_value = mock_response
            
            result = await telegram_bot.send_trade_notification(trade_data)
        
        # Then
        assert result is True
    
    @pytest.mark.asyncio
    async def test_send_performance_report(self, telegram_bot):
        """성과 리포트 전송 테스트"""
        # Given
        report_data = {
            'total_return': 5.5,
            'win_rate': 65.0,
            'max_drawdown': 2.1,
            'sharpe_ratio': 1.8,
            'period': '1개월'
        }
        
        # When
        with patch('aiohttp.ClientSession.post') as mock_post:
            mock_response = AsyncMock()
            mock_response.status = 200
            mock_post.return_value.__aenter__.return_value = mock_response
            
            result = await telegram_bot.send_performance_report(report_data)
        
        # Then
        assert result is True
```

## 🎯 E2E 테스트

### 1. 전체 시스템 워크플로우 테스트
```python
# tests/e2e/test_full_system_workflow.py
import pytest
import asyncio
from unittest.mock import Mock, AsyncMock, patch
from src.trading_system import TradingSystem
from tests.fixtures.test_data import TestDataFactory

class TestFullSystemWorkflow:
    """전체 시스템 워크플로우 테스트"""
    
    @pytest.fixture
    def system_config(self):
        """시스템 설정 픽스처"""
        return {
            'trading': {
                'enabled': True,
                'symbols': ['KRW-BTC'],
                'max_positions': 2
            },
            'risk': {
                'max_position_size': 0.1,
                'daily_loss_limit': 0.02,
                'stop_loss': 0.02,
                'take_profit': 0.05
            },
            'strategies': {
                'volatility_breakout': {
                    'enabled': True,
                    'k_value': 0.7
                }
            },
            'notification': {
                'telegram': {
                    'enabled': True,
                    'bot_token': 'test_token',
                    'chat_id': 'test_chat_id'
                }
            }
        }
    
    @pytest.mark.asyncio
    async def test_complete_trading_cycle(self, system_config):
        """완전한 거래 사이클 테스트"""
        # Given
        with patch.multiple(
            'src.exchange.upbit_api.UpbitAPI',
            get_price=AsyncMock(return_value=50000000),
            place_order=AsyncMock(return_value={'success': True, 'order_id': 'test_123'}),
            get_order_status=AsyncMock(return_value={'status': 'filled'})
        ), patch.multiple(
            'src.notification.telegram_bot.TelegramBot',
            send_message=AsyncMock(return_value=True),
            send_trade_notification=AsyncMock(return_value=True)
        ):
            system = TradingSystem(system_config)
            
            # When: 시스템 시작
            await system.start()
            
            # 가격 데이터 시뮬레이션
            price_data = TestDataFactory.create_price_data()
            for data in price_data[:10]:  # 10개 데이터만 사용
                await system.price_monitor.process_price_data(data)
            
            # 거래 신호 생성 대기
            await asyncio.sleep(0.1)
            
            # When: 시스템 중지
            await system.stop()
        
        # Then
        assert system.is_running is False
        # 추가 검증 로직...
    
    @pytest.mark.asyncio
    async def test_error_recovery_workflow(self, system_config):
        """오류 복구 워크플로우 테스트"""
        # Given
        with patch('src.exchange.upbit_api.UpbitAPI.get_price') as mock_get_price:
            # 첫 번째 호출에서 오류 발생, 두 번째 호출에서 성공
            mock_get_price.side_effect = [
                Exception("API 오류"),
                AsyncMock(return_value=50000000)
            ]
            
            system = TradingSystem(system_config)
            
            # When: 오류 발생 후 복구
            await system.start()
            await asyncio.sleep(0.1)  # 오류 처리 대기
            await system.stop()
        
        # Then
        # 오류 복구 검증 로직...
        assert mock_get_price.call_count >= 2
    
    @pytest.mark.asyncio
    async def test_risk_management_workflow(self, system_config):
        """리스크 관리 워크플로우 테스트"""
        # Given: 손실 한도 초과 시나리오
        system_config['risk']['daily_loss_limit'] = 0.01  # 1% 한도
        
        with patch.multiple(
            'src.exchange.upbit_api.UpbitAPI',
            get_price=AsyncMock(return_value=50000000),
            place_order=AsyncMock(return_value={'success': True, 'order_id': 'test_123'})
        ):
            system = TradingSystem(system_config)
            await system.start()
            
            # When: 손실 한도 초과 시뮬레이션
            system.risk_manager.daily_pnl = -15000  # 1.5% 손실
            
            # 거래 시도
            order_data = {
                'symbol': 'KRW-BTC',
                'side': 'BUY',
                'amount': 0.001,
                'price': 50000000
            }
            
            result = await system.order_executor.execute_order(order_data)
            
            await system.stop()
        
        # Then
        assert result['status'] == 'REJECTED'  # 리스크 한도 초과로 거부
```

## 📊 성능 테스트

### 1. 부하 테스트
```python
# tests/performance/test_load_performance.py
import pytest
import asyncio
import time
from concurrent.futures import ThreadPoolExecutor
from src.trading_system import TradingSystem

class TestLoadPerformance:
    """부하 성능 테스트"""
    
    @pytest.mark.asyncio
    async def test_concurrent_price_updates(self):
        """동시 가격 업데이트 테스트"""
        # Given
        system = TradingSystem(self.get_test_config())
        await system.start()
        
        # When: 100개 동시 가격 업데이트
        start_time = time.time()
        
        tasks = []
        for i in range(100):
            price_data = {
                'symbol': 'KRW-BTC',
                'price': 50000000 + i,
                'volume': 1000,
                'timestamp': datetime.now()
            }
            task = asyncio.create_task(
                system.price_monitor.process_price_data(price_data)
            )
            tasks.append(task)
        
        await asyncio.gather(*tasks)
        
        end_time = time.time()
        processing_time = end_time - start_time
        
        await system.stop()
        
        # Then: 1초 이내 처리
        assert processing_time < 1.0
    
    @pytest.mark.asyncio
    async def test_memory_usage_under_load(self):
        """부하 상태에서 메모리 사용량 테스트"""
        import psutil
        import os
        
        # Given
        process = psutil.Process(os.getpid())
        initial_memory = process.memory_info().rss
        
        system = TradingSystem(self.get_test_config())
        await system.start()
        
        # When: 1000개 가격 데이터 처리
        for i in range(1000):
            price_data = {
                'symbol': 'KRW-BTC',
                'price': 50000000 + i,
                'volume': 1000,
                'timestamp': datetime.now()
            }
            await system.price_monitor.process_price_data(price_data)
        
        current_memory = process.memory_info().rss
        memory_increase = current_memory - initial_memory
        
        await system.stop()
        
        # Then: 메모리 증가량이 100MB 이하
        assert memory_increase < 100 * 1024 * 1024  # 100MB
    
    def test_database_performance(self):
        """데이터베이스 성능 테스트"""
        # Given
        db_manager = DatabaseManager(":memory:")
        
        # When: 1000개 레코드 삽입
        start_time = time.time()
        
        for i in range(1000):
            price_data = {
                'symbol': 'KRW-BTC',
                'price': 50000000 + i,
                'volume': 1000,
                'timestamp': datetime.now()
            }
            db_manager.save_price_data(price_data)
        
        end_time = time.time()
        insert_time = end_time - start_time
        
        # Then: 1000개 레코드가 1초 이내 삽입
        assert insert_time < 1.0
        assert insert_time / 1000 < 0.001  # 레코드당 1ms 이내
```

## 🔍 코드 커버리지

### 커버리지 설정
```python
# pytest.ini
[tool:pytest]
addopts = --cov=src --cov-report=html --cov-report=term-missing --cov-fail-under=80
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
```

### 커버리지 목표
- **전체 커버리지**: 80% 이상
- **핵심 모듈**: 90% 이상 (trading_system, risk_manager, order_executor)
- **유틸리티 모듈**: 70% 이상

## 🚨 품질 게이트

### 1. 코드 품질 검사
```bash
# 코드 스타일 검사
flake8 src/ --max-line-length=88 --extend-ignore=E203,W503

# 타입 검사
mypy src/ --strict

# 보안 검사
bandit -r src/ -f json -o security_report.json
```

### 2. 테스트 실행
```bash
# 단위 테스트
pytest tests/unit/ -v --cov=src

# 통합 테스트
pytest tests/integration/ -v

# E2E 테스트
pytest tests/e2e/ -v

# 성능 테스트
pytest tests/performance/ -v
```

### 3. 품질 게이트 조건
- [ ] 모든 테스트 통과 (100%)
- [ ] 코드 커버리지 80% 이상
- [ ] flake8 오류 0개
- [ ] mypy 오류 0개
- [ ] bandit 보안 이슈 0개
- [ ] 성능 테스트 통과

## 📋 테스트 체크리스트

### 개발 단계별 테스트
- [ ] **Phase 1**: 기본 클래스 단위 테스트
- [ ] **Phase 2**: API 연동 통합 테스트
- [ ] **Phase 3**: 전략 로직 단위 테스트
- [ ] **Phase 4**: 리스크 관리 통합 테스트
- [ ] **Phase 5**: 웹 인터페이스 E2E 테스트
- [ ] **Phase 6**: 전체 시스템 E2E 테스트

### 릴리즈 전 필수 테스트
- [ ] 모든 단위 테스트 통과
- [ ] 모든 통합 테스트 통과
- [ ] 모든 E2E 테스트 통과
- [ ] 성능 테스트 통과
- [ ] 보안 테스트 통과
- [ ] 코드 커버리지 목표 달성

이 테스트 및 품질보증 가이드라인은 PRD.md의 요구사항을 기반으로 체계적인 테스트 전략을 제공합니다. 각 테스트 유형별로 구체적인 구현 방법과 검증 기준을 제시하여 높은 품질의 자동매매 시스템을 구축할 수 있도록 도와줍니다.