---
globs: src/**/*.py
description: ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ í•µì‹¬ ê¸°ëŠ¥ êµ¬í˜„ ê°€ì´ë“œ
---

# ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ í•µì‹¬ ê¸°ëŠ¥ êµ¬í˜„ ê°€ì´ë“œ

## ğŸ¯ í•µì‹¬ ê¸°ëŠ¥ ê°œìš”

### 1. ê°€ê²© ëª¨ë‹ˆí„°ë§ (F001)
- ì‹¤ì‹œê°„ ê°€ê²© ë°ì´í„° ìˆ˜ì§‘ ë° ë¶„ì„
- ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚°
- ë°ì´í„° í’ˆì§ˆ ê´€ë¦¬

### 2. ì£¼ë¬¸ ì‹¤í–‰ (F002)
- ë§¤ìˆ˜/ë§¤ë„ ì£¼ë¬¸ ìë™ ì‹¤í–‰
- ì£¼ë¬¸ ìƒíƒœ ì¶”ì  ë° ê´€ë¦¬
- ë¶€ë¶„ ì²´ê²° ì²˜ë¦¬

### 3. ë¦¬ìŠ¤í¬ ê´€ë¦¬ (F003) - Critical
- í¬ì§€ì…˜ í¬ê¸° ê´€ë¦¬
- ì†ì ˆ/ìµì ˆ ìë™ ì‹¤í–‰
- ì¼ì¼ ì†ì‹¤ í•œë„ ê´€ë¦¬

### 4. ì•Œë¦¼ ì‹œìŠ¤í…œ (F004)
- í…”ë ˆê·¸ë¨ ì‹¤ì‹œê°„ ì•Œë¦¼
- ê±°ë˜ ë° ì„±ê³¼ ë¦¬í¬íŠ¸
- ì˜¤ë¥˜ ë° ë¦¬ìŠ¤í¬ ì•Œë¦¼

### 5. ë°ì´í„° ê´€ë¦¬ (F005)
- SQLite ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥
- ë°ì´í„° ë°±ì—… ë° ë³µêµ¬
- ì„±ê³¼ ë¶„ì„ ë° ë¦¬í¬íŠ¸

### 6. ì„¤ì • ê´€ë¦¬ (F006)
- ì›¹ ê¸°ë°˜ ì„¤ì • ì¸í„°í˜ì´ìŠ¤
- ì „ëµ ë§¤ê°œë³€ìˆ˜ ê´€ë¦¬
- API í‚¤ ë° ë³´ì•ˆ ì„¤ì •

## ğŸ“Š 1. ê°€ê²© ëª¨ë‹ˆí„°ë§ êµ¬í˜„

### 1.1 ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì§‘
```python
import asyncio
import websockets
import json
from typing import Dict, List, Callable
from datetime import datetime
import logging

class PriceMonitor:
    """ì‹¤ì‹œê°„ ê°€ê²© ëª¨ë‹ˆí„°ë§ í´ë˜ìŠ¤"""
    
    def __init__(self, symbols: List[str], callback: Callable):
        self.symbols = symbols
        self.callback = callback
        self.websocket = None
        self.is_running = False
        self.logger = logging.getLogger(__name__)
    
    async def start_monitoring(self) -> None:
        """WebSocketì„ í†µí•œ ì‹¤ì‹œê°„ ì‹œì„¸ ìˆ˜ì‹  ì‹œì‘"""
        try:
            # ì—…ë¹„íŠ¸ WebSocket ì—°ê²°
            uri = "wss://api.upbit.com/websocket/v1"
            self.websocket = await websockets.connect(uri)
            
            # êµ¬ë… ë©”ì‹œì§€ ì „ì†¡
            subscribe_message = [
                {"ticket": "crypto-auto-trader"},
                {"type": "ticker", "codes": self.symbols},
                {"format": "SIMPLE"}
            ]
            
            await self.websocket.send(json.dumps(subscribe_message))
            self.is_running = True
            
            # ë©”ì‹œì§€ ìˆ˜ì‹  ë£¨í”„
            async for message in self.websocket:
                await self._process_message(message)
                
        except Exception as e:
            self.logger.error(f"ê°€ê²© ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜: {e}")
            await self._reconnect()
    
    async def _process_message(self, message: str) -> None:
        """ìˆ˜ì‹ ëœ ë©”ì‹œì§€ ì²˜ë¦¬"""
        try:
            data = json.loads(message)
            
            # ê°€ê²© ë°ì´í„° ì¶”ì¶œ
            price_data = {
                'symbol': data['cd'],
                'price': float(data['tp']),
                'volume': float(data['tv']),
                'timestamp': datetime.now(),
                'change_rate': float(data['c'])
            }
            
            # ì½œë°± í•¨ìˆ˜ í˜¸ì¶œ
            await self.callback(price_data)
            
        except Exception as e:
            self.logger.error(f"ë©”ì‹œì§€ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
    
    async def _reconnect(self) -> None:
        """ì—°ê²° ì¬ì‹œë„"""
        retry_count = 0
        max_retries = 5
        
        while retry_count < max_retries:
            try:
                await asyncio.sleep(2 ** retry_count)  # ì§€ìˆ˜ ë°±ì˜¤í”„
                await self.start_monitoring()
                break
            except Exception as e:
                retry_count += 1
                self.logger.error(f"ì¬ì—°ê²° ì‹œë„ {retry_count} ì‹¤íŒ¨: {e}")
```

### 1.2 ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚°
```python
import pandas as pd
import numpy as np
from typing import List, Dict
from dataclasses import dataclass

@dataclass
class TechnicalIndicators:
    """ê¸°ìˆ ì  ì§€í‘œ ë°ì´í„° í´ë˜ìŠ¤"""
    sma_5: float
    sma_20: float
    ema_12: float
    ema_26: float
    rsi: float
    macd: float
    macd_signal: float
    bollinger_upper: float
    bollinger_lower: float
    atr: float

class TechnicalAnalyzer:
    """ê¸°ìˆ ì  ë¶„ì„ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.price_history: List[float] = []
        self.volume_history: List[float] = []
    
    def add_price_data(self, price: float, volume: float) -> None:
        """ê°€ê²© ë°ì´í„° ì¶”ê°€"""
        self.price_history.append(price)
        self.volume_history.append(volume)
        
        # ìµœëŒ€ 200ê°œ ë°ì´í„°ë§Œ ìœ ì§€
        if len(self.price_history) > 200:
            self.price_history.pop(0)
            self.volume_history.pop(0)
    
    def calculate_indicators(self) -> TechnicalIndicators:
        """ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚°"""
        if len(self.price_history) < 26:
            raise ValueError("ì¶©ë¶„í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤ (ìµœì†Œ 26ê°œ í•„ìš”)")
        
        df = pd.DataFrame({
            'price': self.price_history,
            'volume': self.volume_history
        })
        
        # ì´ë™í‰ê·  ê³„ì‚°
        sma_5 = df['price'].rolling(window=5).mean().iloc[-1]
        sma_20 = df['price'].rolling(window=20).mean().iloc[-1]
        ema_12 = df['price'].ewm(span=12).mean().iloc[-1]
        ema_26 = df['price'].ewm(span=26).mean().iloc[-1]
        
        # RSI ê³„ì‚°
        rsi = self._calculate_rsi(df['price'], 14)
        
        # MACD ê³„ì‚°
        macd = ema_12 - ema_26
        macd_signal = df['price'].ewm(span=9).mean().iloc[-1]
        
        # ë³¼ë¦°ì € ë°´ë“œ ê³„ì‚°
        bb_std = df['price'].rolling(window=20).std().iloc[-1]
        bb_middle = sma_20
        bollinger_upper = bb_middle + (bb_std * 2)
        bollinger_lower = bb_middle - (bb_std * 2)
        
        # ATR ê³„ì‚°
        atr = self._calculate_atr(df, 14)
        
        return TechnicalIndicators(
            sma_5=sma_5,
            sma_20=sma_20,
            ema_12=ema_12,
            ema_26=ema_26,
            rsi=rsi,
            macd=macd,
            macd_signal=macd_signal,
            bollinger_upper=bollinger_upper,
            bollinger_lower=bollinger_lower,
            atr=atr
        )
    
    def _calculate_rsi(self, prices: pd.Series, period: int = 14) -> float:
        """RSI ê³„ì‚°"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi.iloc[-1]
    
    def _calculate_atr(self, df: pd.DataFrame, period: int = 14) -> float:
        """ATR ê³„ì‚°"""
        high_low = df['price'].diff()
        high_close = np.abs(df['price'] - df['price'].shift())
        low_close = np.abs(df['price'] - df['price'].shift())
        
        ranges = pd.concat([high_low, high_close, low_close], axis=1)
        true_range = np.max(ranges, axis=1)
        atr = true_range.rolling(period).mean()
        return atr.iloc[-1]
```

## ğŸ’° 2. ì£¼ë¬¸ ì‹¤í–‰ êµ¬í˜„

### 2.1 ì£¼ë¬¸ ê´€ë¦¬ì
```python
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum
from typing import Optional, List
import asyncio
import logging

class OrderType(Enum):
    """ì£¼ë¬¸ ìœ í˜•"""
    MARKET = "market"
    LIMIT = "limit"
    STOP_LOSS = "stop_loss"
    TAKE_PROFIT = "take_profit"

class OrderSide(Enum):
    """ì£¼ë¬¸ ë°©í–¥"""
    BUY = "buy"
    SELL = "sell"

class OrderStatus(Enum):
    """ì£¼ë¬¸ ìƒíƒœ"""
    PENDING = "pending"
    FILLED = "filled"
    PARTIALLY_FILLED = "partially_filled"
    CANCELLED = "cancelled"
    FAILED = "failed"

@dataclass
class Order:
    """ì£¼ë¬¸ ë°ì´í„° í´ë˜ìŠ¤"""
    id: str
    symbol: str
    side: OrderSide
    order_type: OrderType
    amount: float
    price: Optional[float] = None
    status: OrderStatus = OrderStatus.PENDING
    filled_amount: float = 0.0
    average_price: float = 0.0
    created_at: datetime = None
    updated_at: datetime = None

class OrderExecutor:
    """ì£¼ë¬¸ ì‹¤í–‰ í´ë˜ìŠ¤"""
    
    def __init__(self, exchange_api, risk_manager):
        self.exchange_api = exchange_api
        self.risk_manager = risk_manager
        self.active_orders: Dict[str, Order] = {}
        self.logger = logging.getLogger(__name__)
    
    async def execute_order(self, order: Order) -> Order:
        """ì£¼ë¬¸ ì‹¤í–‰"""
        try:
            # ë¦¬ìŠ¤í¬ ê²€ì¦
            if not await self.risk_manager.validate_order(order):
                order.status = OrderStatus.FAILED
                self.logger.warning(f"ì£¼ë¬¸ ë¦¬ìŠ¤í¬ ê²€ì¦ ì‹¤íŒ¨: {order.id}")
                return order
            
            # ì£¼ë¬¸ ì‹¤í–‰
            if order.order_type == OrderType.MARKET:
                result = await self._execute_market_order(order)
            elif order.order_type == OrderType.LIMIT:
                result = await self._execute_limit_order(order)
            else:
                raise ValueError(f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ì£¼ë¬¸ ìœ í˜•: {order.order_type}")
            
            # ê²°ê³¼ ì²˜ë¦¬
            order.status = result['status']
            order.filled_amount = result.get('filled_amount', 0.0)
            order.average_price = result.get('average_price', 0.0)
            order.updated_at = datetime.now()
            
            # í™œì„± ì£¼ë¬¸ì— ì¶”ê°€
            if order.status in [OrderStatus.PENDING, OrderStatus.PARTIALLY_FILLED]:
                self.active_orders[order.id] = order
            
            self.logger.info(f"ì£¼ë¬¸ ì‹¤í–‰ ì™„ë£Œ: {order.id} - {order.status}")
            return order
            
        except Exception as e:
            order.status = OrderStatus.FAILED
            self.logger.error(f"ì£¼ë¬¸ ì‹¤í–‰ ì˜¤ë¥˜: {e}")
            return order
    
    async def _execute_market_order(self, order: Order) -> Dict:
        """ì‹œì¥ê°€ ì£¼ë¬¸ ì‹¤í–‰"""
        return await self.exchange_api.place_market_order(
            symbol=order.symbol,
            side=order.side.value,
            amount=order.amount
        )
    
    async def _execute_limit_order(self, order: Order) -> Dict:
        """ì§€ì •ê°€ ì£¼ë¬¸ ì‹¤í–‰"""
        return await self.exchange_api.place_limit_order(
            symbol=order.symbol,
            side=order.side.value,
            amount=order.amount,
            price=order.price
        )
    
    async def cancel_order(self, order_id: str) -> bool:
        """ì£¼ë¬¸ ì·¨ì†Œ"""
        try:
            result = await self.exchange_api.cancel_order(order_id)
            if result['success']:
                if order_id in self.active_orders:
                    self.active_orders[order_id].status = OrderStatus.CANCELLED
                    del self.active_orders[order_id]
                self.logger.info(f"ì£¼ë¬¸ ì·¨ì†Œ ì™„ë£Œ: {order_id}")
                return True
            return False
        except Exception as e:
            self.logger.error(f"ì£¼ë¬¸ ì·¨ì†Œ ì˜¤ë¥˜: {e}")
            return False
    
    async def update_order_status(self, order_id: str) -> Optional[Order]:
        """ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸"""
        try:
            status = await self.exchange_api.get_order_status(order_id)
            if order_id in self.active_orders:
                order = self.active_orders[order_id]
                order.status = OrderStatus(status['status'])
                order.filled_amount = status.get('filled_amount', 0.0)
                order.average_price = status.get('average_price', 0.0)
                order.updated_at = datetime.now()
                
                # ì™„ì „ ì²´ê²°ëœ ì£¼ë¬¸ì€ í™œì„± ëª©ë¡ì—ì„œ ì œê±°
                if order.status in [OrderStatus.FILLED, OrderStatus.CANCELLED, OrderStatus.FAILED]:
                    del self.active_orders[order_id]
                
                return order
        except Exception as e:
            self.logger.error(f"ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
        return None
```

## âš ï¸ 3. ë¦¬ìŠ¤í¬ ê´€ë¦¬ êµ¬í˜„

### 3.1 ë¦¬ìŠ¤í¬ ê´€ë¦¬ì
```python
from dataclasses import dataclass
from typing import Dict, List, Optional
import logging
from datetime import datetime, timedelta

@dataclass
class RiskLimits:
    """ë¦¬ìŠ¤í¬ í•œë„ ì„¤ì •"""
    max_position_size: float = 0.1  # ê³„ì¢Œ ëŒ€ë¹„ ìµœëŒ€ í¬ì§€ì…˜ í¬ê¸° (10%)
    daily_loss_limit: float = 0.02  # ì¼ì¼ ìµœëŒ€ ì†ì‹¤ (2%)
    max_concurrent_positions: int = 5  # ìµœëŒ€ ë™ì‹œ í¬ì§€ì…˜ ìˆ˜
    stop_loss_percentage: float = 0.02  # ì†ì ˆ ë¹„ìœ¨ (2%)
    take_profit_percentage: float = 0.05  # ìµì ˆ ë¹„ìœ¨ (5%)

@dataclass
class Position:
    """í¬ì§€ì…˜ ë°ì´í„°"""
    symbol: str
    side: str  # 'long' or 'short'
    amount: float
    entry_price: float
    current_price: float
    unrealized_pnl: float
    created_at: datetime

class RiskManager:
    """ë¦¬ìŠ¤í¬ ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self, account_balance: float, risk_limits: RiskLimits):
        self.account_balance = account_balance
        self.risk_limits = risk_limits
        self.positions: Dict[str, Position] = {}
        self.daily_pnl = 0.0
        self.last_reset_date = datetime.now().date()
        self.logger = logging.getLogger(__name__)
    
    async def validate_order(self, order: Order) -> bool:
        """ì£¼ë¬¸ ë¦¬ìŠ¤í¬ ê²€ì¦"""
        try:
            # ì¼ì¼ ì†ì‹¤ í•œë„ í™•ì¸
            if not self._check_daily_loss_limit():
                self.logger.warning("ì¼ì¼ ì†ì‹¤ í•œë„ ì´ˆê³¼")
                return False
            
            # í¬ì§€ì…˜ í¬ê¸° í™•ì¸
            if not self._check_position_size(order):
                self.logger.warning("í¬ì§€ì…˜ í¬ê¸° í•œë„ ì´ˆê³¼")
                return False
            
            # ë™ì‹œ í¬ì§€ì…˜ ìˆ˜ í™•ì¸
            if not self._check_concurrent_positions():
                self.logger.warning("ìµœëŒ€ ë™ì‹œ í¬ì§€ì…˜ ìˆ˜ ì´ˆê³¼")
                return False
            
            return True
            
        except Exception as e:
            self.logger.error(f"ë¦¬ìŠ¤í¬ ê²€ì¦ ì˜¤ë¥˜: {e}")
            return False
    
    def _check_daily_loss_limit(self) -> bool:
        """ì¼ì¼ ì†ì‹¤ í•œë„ í™•ì¸"""
        # ë‚ ì§œê°€ ë°”ë€Œë©´ ì¼ì¼ ì†ìµ ì´ˆê¸°í™”
        if datetime.now().date() != self.last_reset_date:
            self.daily_pnl = 0.0
            self.last_reset_date = datetime.now().date()
        
        max_daily_loss = self.account_balance * self.risk_limits.daily_loss_limit
        return self.daily_pnl >= -max_daily_loss
    
    def _check_position_size(self, order: Order) -> bool:
        """í¬ì§€ì…˜ í¬ê¸° í™•ì¸"""
        order_value = order.amount * (order.price or 0)
        max_position_value = self.account_balance * self.risk_limits.max_position_size
        
        return order_value <= max_position_value
    
    def _check_concurrent_positions(self) -> bool:
        """ë™ì‹œ í¬ì§€ì…˜ ìˆ˜ í™•ì¸"""
        return len(self.positions) < self.risk_limits.max_concurrent_positions
    
    def update_position(self, symbol: str, side: str, amount: float, 
                       entry_price: float, current_price: float) -> None:
        """í¬ì§€ì…˜ ì—…ë°ì´íŠ¸"""
        unrealized_pnl = self._calculate_unrealized_pnl(
            side, amount, entry_price, current_price
        )
        
        position = Position(
            symbol=symbol,
            side=side,
            amount=amount,
            entry_price=entry_price,
            current_price=current_price,
            unrealized_pnl=unrealized_pnl,
            created_at=datetime.now()
        )
        
        self.positions[symbol] = position
        self._update_daily_pnl()
    
    def _calculate_unrealized_pnl(self, side: str, amount: float, 
                                entry_price: float, current_price: float) -> float:
        """ë¯¸ì‹¤í˜„ ì†ìµ ê³„ì‚°"""
        if side == 'long':
            return (current_price - entry_price) * amount
        else:  # short
            return (entry_price - current_price) * amount
    
    def _update_daily_pnl(self) -> None:
        """ì¼ì¼ ì†ìµ ì—…ë°ì´íŠ¸"""
        self.daily_pnl = sum(pos.unrealized_pnl for pos in self.positions.values())
    
    def check_stop_loss(self, symbol: str, current_price: float) -> bool:
        """ì†ì ˆ í™•ì¸"""
        if symbol not in self.positions:
            return False
        
        position = self.positions[symbol]
        loss_percentage = abs(position.unrealized_pnl) / (position.entry_price * position.amount)
        
        return loss_percentage >= self.risk_limits.stop_loss_percentage
    
    def check_take_profit(self, symbol: str, current_price: float) -> bool:
        """ìµì ˆ í™•ì¸"""
        if symbol not in self.positions:
            return False
        
        position = self.positions[symbol]
        profit_percentage = position.unrealized_pnl / (position.entry_price * position.amount)
        
        return profit_percentage >= self.risk_limits.take_profit_percentage
    
    def get_risk_summary(self) -> Dict:
        """ë¦¬ìŠ¤í¬ ìš”ì•½ ì •ë³´"""
        return {
            'account_balance': self.account_balance,
            'daily_pnl': self.daily_pnl,
            'daily_pnl_percentage': (self.daily_pnl / self.account_balance) * 100,
            'active_positions': len(self.positions),
            'max_positions': self.risk_limits.max_concurrent_positions,
            'total_unrealized_pnl': sum(pos.unrealized_pnl for pos in self.positions.values())
        }
```

## ğŸ“± 4. ì•Œë¦¼ ì‹œìŠ¤í…œ êµ¬í˜„

### 4.1 í…”ë ˆê·¸ë¨ ë´‡
```python
import asyncio
import aiohttp
import json
from typing import Dict, List, Optional
from datetime import datetime
import logging

class TelegramBot:
    """í…”ë ˆê·¸ë¨ ë´‡ í´ë˜ìŠ¤"""
    
    def __init__(self, bot_token: str, chat_id: str):
        self.bot_token = bot_token
        self.chat_id = chat_id
        self.base_url = f"https://api.telegram.org/bot{bot_token}"
        self.logger = logging.getLogger(__name__)
    
    async def send_message(self, message: str, parse_mode: str = "Markdown") -> bool:
        """ë©”ì‹œì§€ ì „ì†¡"""
        try:
            url = f"{self.base_url}/sendMessage"
            data = {
                'chat_id': self.chat_id,
                'text': message,
                'parse_mode': parse_mode
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=data) as response:
                    if response.status == 200:
                        self.logger.info("í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ ì„±ê³µ")
                        return True
                    else:
                        self.logger.error(f"í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: {response.status}")
                        return False
                        
        except Exception as e:
            self.logger.error(f"í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ ì˜¤ë¥˜: {e}")
            return False
    
    async def send_trade_notification(self, trade_data: Dict) -> bool:
        """ê±°ë˜ ì•Œë¦¼ ì „ì†¡"""
        message = self._format_trade_message(trade_data)
        return await self.send_message(message)
    
    async def send_performance_report(self, report_data: Dict) -> bool:
        """ì„±ê³¼ ë¦¬í¬íŠ¸ ì „ì†¡"""
        message = self._format_performance_message(report_data)
        return await self.send_message(message)
    
    async def send_error_notification(self, error_data: Dict) -> bool:
        """ì˜¤ë¥˜ ì•Œë¦¼ ì „ì†¡"""
        message = self._format_error_message(error_data)
        return await self.send_message(message)
    
    def _format_trade_message(self, trade_data: Dict) -> str:
        """ê±°ë˜ ë©”ì‹œì§€ í¬ë§·íŒ…"""
        return f"""
ğŸš€ *ê±°ë˜ ì‹¤í–‰ ì•Œë¦¼*

ğŸ“Š *ì‹¬ë³¼*: `{trade_data['symbol']}`
ğŸ“ˆ *ì•¡ì…˜*: `{trade_data['action']}`
ğŸ’° *ìˆ˜ëŸ‰*: `{trade_data['amount']}`
ğŸ’µ *ê°€ê²©*: `{trade_data['price']:,}ì›`
ğŸ“… *ì‹œê°„*: `{trade_data['timestamp']}`
ğŸ¯ *ì „ëµ*: `{trade_data['strategy']}`
        """.strip()
    
    def _format_performance_message(self, report_data: Dict) -> str:
        """ì„±ê³¼ ë¦¬í¬íŠ¸ ë©”ì‹œì§€ í¬ë§·íŒ…"""
        return f"""
ğŸ“Š *ì„±ê³¼ ë¦¬í¬íŠ¸*

ğŸ’° *ì´ ìˆ˜ìµë¥ *: `{report_data['total_return']:.2f}%`
ğŸ“ˆ *ìŠ¹ë¥ *: `{report_data['win_rate']:.2f}%`
ğŸ“‰ *ìµœëŒ€ ë‚™í­*: `{report_data['max_drawdown']:.2f}%`
ğŸ¯ *ìƒ¤í”„ ë¹„ìœ¨*: `{report_data['sharpe_ratio']:.2f}`
ğŸ“… *ê¸°ê°„*: `{report_data['period']}`
        """.strip()
    
    def _format_error_message(self, error_data: Dict) -> str:
        """ì˜¤ë¥˜ ë©”ì‹œì§€ í¬ë§·íŒ…"""
        return f"""
âš ï¸ *ì‹œìŠ¤í…œ ì˜¤ë¥˜ ì•Œë¦¼*

ğŸ” *ì˜¤ë¥˜ ìœ í˜•*: `{error_data['error_type']}`
ğŸ“ *ë©”ì‹œì§€*: `{error_data['message']}`
ğŸ“ *ìœ„ì¹˜*: `{error_data['location']}`
ğŸ“… *ì‹œê°„*: `{error_data['timestamp']}`
        """.strip()
```

## ğŸ—„ï¸ 5. ë°ì´í„° ê´€ë¦¬ êµ¬í˜„

### 5.1 ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ì
```python
import sqlite3
import json
from typing import Dict, List, Optional, Any
from datetime import datetime
import logging

class DatabaseManager:
    """ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.logger = logging.getLogger(__name__)
        self._init_database()
    
    def _init_database(self) -> None:
        """ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # ê°€ê²© ë°ì´í„° í…Œì´ë¸”
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS price_data (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        symbol TEXT NOT NULL,
                        price REAL NOT NULL,
                        volume REAL NOT NULL,
                        timestamp DATETIME NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # ê±°ë˜ ë‚´ì—­ í…Œì´ë¸”
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS trades (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        order_id TEXT UNIQUE NOT NULL,
                        symbol TEXT NOT NULL,
                        side TEXT NOT NULL,
                        amount REAL NOT NULL,
                        price REAL NOT NULL,
                        status TEXT NOT NULL,
                        strategy TEXT NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # ì„±ê³¼ ë°ì´í„° í…Œì´ë¸”
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS performance (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        date DATE NOT NULL,
                        total_return REAL NOT NULL,
                        daily_pnl REAL NOT NULL,
                        win_rate REAL NOT NULL,
                        max_drawdown REAL NOT NULL,
                        sharpe_ratio REAL NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # ì¸ë±ìŠ¤ ìƒì„±
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_price_symbol_time ON price_data(symbol, timestamp)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_trades_symbol ON trades(symbol)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_performance_date ON performance(date)")
                
                conn.commit()
                self.logger.info("ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì™„ë£Œ")
                
        except Exception as e:
            self.logger.error(f"ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì˜¤ë¥˜: {e}")
            raise
    
    def save_price_data(self, price_data: Dict[str, Any]) -> bool:
        """ê°€ê²© ë°ì´í„° ì €ì¥"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    INSERT INTO price_data (symbol, price, volume, timestamp)
                    VALUES (?, ?, ?, ?)
                """, (
                    price_data['symbol'],
                    price_data['price'],
                    price_data['volume'],
                    price_data['timestamp']
                ))
                conn.commit()
                return True
        except Exception as e:
            self.logger.error(f"ê°€ê²© ë°ì´í„° ì €ì¥ ì˜¤ë¥˜: {e}")
            return False
    
    def save_trade(self, trade_data: Dict[str, Any]) -> bool:
        """ê±°ë˜ ë‚´ì—­ ì €ì¥"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    INSERT OR REPLACE INTO trades 
                    (order_id, symbol, side, amount, price, status, strategy, updated_at)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    trade_data['order_id'],
                    trade_data['symbol'],
                    trade_data['side'],
                    trade_data['amount'],
                    trade_data['price'],
                    trade_data['status'],
                    trade_data['strategy'],
                    datetime.now()
                ))
                conn.commit()
                return True
        except Exception as e:
            self.logger.error(f"ê±°ë˜ ë‚´ì—­ ì €ì¥ ì˜¤ë¥˜: {e}")
            return False
    
    def get_price_history(self, symbol: str, days: int = 30) -> List[Dict]:
        """ê°€ê²© íˆìŠ¤í† ë¦¬ ì¡°íšŒ"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.cursor()
                cursor.execute("""
                    SELECT * FROM price_data 
                    WHERE symbol = ? 
                    AND timestamp >= datetime('now', '-{} days')
                    ORDER BY timestamp ASC
                """.format(days), (symbol,))
                
                rows = cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            self.logger.error(f"ê°€ê²© íˆìŠ¤í† ë¦¬ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return []
    
    def get_trade_history(self, symbol: Optional[str] = None, 
                         days: int = 30) -> List[Dict]:
        """ê±°ë˜ íˆìŠ¤í† ë¦¬ ì¡°íšŒ"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.cursor()
                
                if symbol:
                    cursor.execute("""
                        SELECT * FROM trades 
                        WHERE symbol = ? 
                        AND created_at >= datetime('now', '-{} days')
                        ORDER BY created_at DESC
                    """.format(days), (symbol,))
                else:
                    cursor.execute("""
                        SELECT * FROM trades 
                        WHERE created_at >= datetime('now', '-{} days')
                        ORDER BY created_at DESC
                    """.format(days))
                
                rows = cursor.fetchall()
                return [dict(row) for row in rows]
        except Exception as e:
            self.logger.error(f"ê±°ë˜ íˆìŠ¤í† ë¦¬ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return []
    
    def calculate_performance_metrics(self, days: int = 30) -> Dict[str, float]:
        """ì„±ê³¼ ì§€í‘œ ê³„ì‚°"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # ê±°ë˜ ë°ì´í„° ì¡°íšŒ
                cursor.execute("""
                    SELECT side, amount, price, created_at 
                    FROM trades 
                    WHERE status = 'filled' 
                    AND created_at >= datetime('now', '-{} days')
                    ORDER BY created_at ASC
                """.format(days))
                
                trades = cursor.fetchall()
                
                if not trades:
                    return {
                        'total_return': 0.0,
                        'win_rate': 0.0,
                        'max_drawdown': 0.0,
                        'sharpe_ratio': 0.0
                    }
                
                # ì„±ê³¼ ê³„ì‚° ë¡œì§
                total_return = self._calculate_total_return(trades)
                win_rate = self._calculate_win_rate(trades)
                max_drawdown = self._calculate_max_drawdown(trades)
                sharpe_ratio = self._calculate_sharpe_ratio(trades)
                
                return {
                    'total_return': total_return,
                    'win_rate': win_rate,
                    'max_drawdown': max_drawdown,
                    'sharpe_ratio': sharpe_ratio
                }
                
        except Exception as e:
            self.logger.error(f"ì„±ê³¼ ì§€í‘œ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return {}
    
    def _calculate_total_return(self, trades: List) -> float:
        """ì´ ìˆ˜ìµë¥  ê³„ì‚°"""
        # êµ¬í˜„ ë¡œì§
        pass
    
    def _calculate_win_rate(self, trades: List) -> float:
        """ìŠ¹ë¥  ê³„ì‚°"""
        # êµ¬í˜„ ë¡œì§
        pass
    
    def _calculate_max_drawdown(self, trades: List) -> float:
        """ìµœëŒ€ ë‚™í­ ê³„ì‚°"""
        # êµ¬í˜„ ë¡œì§
        pass
    
    def _calculate_sharpe_ratio(self, trades: List) -> float:
        """ìƒ¤í”„ ë¹„ìœ¨ ê³„ì‚°"""
        # êµ¬í˜„ ë¡œì§
        pass
```

## âš™ï¸ 6. ì„¤ì • ê´€ë¦¬ êµ¬í˜„

### 6.1 ì„¤ì • ê´€ë¦¬ì
```python
import yaml
import json
from typing import Dict, Any, Optional
from pathlib import Path
import logging

class ConfigManager:
    """ì„¤ì • ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self, config_dir: str = "config"):
        self.config_dir = Path(config_dir)
        self.config_dir.mkdir(exist_ok=True)
        self.logger = logging.getLogger(__name__)
        self._config_cache: Dict[str, Any] = {}
    
    def load_config(self, config_name: str) -> Dict[str, Any]:
        """ì„¤ì • íŒŒì¼ ë¡œë“œ"""
        try:
            config_path = self.config_dir / f"{config_name}.yaml"
            
            if not config_path.exists():
                self.logger.warning(f"ì„¤ì • íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {config_path}")
                return self._get_default_config(config_name)
            
            with open(config_path, 'r', encoding='utf-8') as f:
                config = yaml.safe_load(f)
            
            self._config_cache[config_name] = config
            return config
            
        except Exception as e:
            self.logger.error(f"ì„¤ì • ë¡œë“œ ì˜¤ë¥˜: {e}")
            return self._get_default_config(config_name)
    
    def save_config(self, config_name: str, config: Dict[str, Any]) -> bool:
        """ì„¤ì • íŒŒì¼ ì €ì¥"""
        try:
            config_path = self.config_dir / f"{config_name}.yaml"
            
            with open(config_path, 'w', encoding='utf-8') as f:
                yaml.dump(config, f, default_flow_style=False, allow_unicode=True)
            
            self._config_cache[config_name] = config
            self.logger.info(f"ì„¤ì • ì €ì¥ ì™„ë£Œ: {config_name}")
            return True
            
        except Exception as e:
            self.logger.error(f"ì„¤ì • ì €ì¥ ì˜¤ë¥˜: {e}")
            return False
    
    def get_config_value(self, config_name: str, key: str, default: Any = None) -> Any:
        """ì„¤ì • ê°’ ì¡°íšŒ"""
        config = self._config_cache.get(config_name)
        if not config:
            config = self.load_config(config_name)
        
        keys = key.split('.')
        value = config
        
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                return default
        
        return value
    
    def update_config_value(self, config_name: str, key: str, value: Any) -> bool:
        """ì„¤ì • ê°’ ì—…ë°ì´íŠ¸"""
        try:
            config = self.load_config(config_name)
            
            keys = key.split('.')
            current = config
            
            for k in keys[:-1]:
                if k not in current:
                    current[k] = {}
                current = current[k]
            
            current[keys[-1]] = value
            
            return self.save_config(config_name, config)
            
        except Exception as e:
            self.logger.error(f"ì„¤ì • ê°’ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
            return False
    
    def _get_default_config(self, config_name: str) -> Dict[str, Any]:
        """ê¸°ë³¸ ì„¤ì • ë°˜í™˜"""
        default_configs = {
            'main': {
                'trading': {
                    'enabled': True,
                    'symbols': ['KRW-BTC', 'KRW-ETH'],
                    'max_positions': 5
                },
                'risk': {
                    'max_position_size': 0.1,
                    'daily_loss_limit': 0.02,
                    'stop_loss': 0.02,
                    'take_profit': 0.05
                },
                'notification': {
                    'telegram': {
                        'enabled': True,
                        'bot_token': '',
                        'chat_id': ''
                    }
                }
            },
            'strategies': {
                'volatility_breakout': {
                    'enabled': True,
                    'k_value': 0.7,
                    'volume_filter': 1.5,
                    'rsi_threshold': 30
                },
                'ma_crossover': {
                    'enabled': False,
                    'short_period': 5,
                    'long_period': 20
                }
            }
        }
        
        return default_configs.get(config_name, {})
```

## ğŸ§ª í…ŒìŠ¤íŠ¸ êµ¬í˜„ ì˜ˆì‹œ

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
```python
import pytest
from unittest.mock import Mock, patch
from src.risk.risk_manager import RiskManager, RiskLimits
from src.order.order_executor import OrderExecutor, Order, OrderSide, OrderType

class TestRiskManager:
    """ë¦¬ìŠ¤í¬ ê´€ë¦¬ì í…ŒìŠ¤íŠ¸"""
    
    def setup_method(self):
        """í…ŒìŠ¤íŠ¸ ì„¤ì •"""
        self.risk_limits = RiskLimits(
            max_position_size=0.1,
            daily_loss_limit=0.02,
            max_concurrent_positions=5
        )
        self.risk_manager = RiskManager(1000000, self.risk_limits)
    
    def test_daily_loss_limit_check(self):
        """ì¼ì¼ ì†ì‹¤ í•œë„ í™•ì¸ í…ŒìŠ¤íŠ¸"""
        # Given
        self.risk_manager.daily_pnl = -25000  # 2.5% ì†ì‹¤
        
        # When
        result = self.risk_manager._check_daily_loss_limit()
        
        # Then
        assert result is False  # 2% í•œë„ ì´ˆê³¼
    
    def test_position_size_check(self):
        """í¬ì§€ì…˜ í¬ê¸° í™•ì¸ í…ŒìŠ¤íŠ¸"""
        # Given
        order = Order(
            id="test_order",
            symbol="KRW-BTC",
            side=OrderSide.BUY,
            order_type=OrderType.MARKET,
            amount=0.001,
            price=50000000  # 5ë§Œì›
        )
        
        # When
        result = self.risk_manager._check_position_size(order)
        
        # Then
        assert result is True  # 5ë§Œì›ì€ 10% í•œë„ ë‚´
    
    def test_concurrent_positions_check(self):
        """ë™ì‹œ í¬ì§€ì…˜ ìˆ˜ í™•ì¸ í…ŒìŠ¤íŠ¸"""
        # Given
        for i in range(5):
            self.risk_manager.positions[f"position_{i}"] = Mock()
        
        # When
        result = self.risk_manager._check_concurrent_positions()
        
        # Then
        assert result is False  # ìµœëŒ€ 5ê°œ ì´ˆê³¼
```

ì´ êµ¬í˜„ ê°€ì´ë“œëŠ” PRD.mdì˜ ìš”êµ¬ì‚¬í•­ì„ ê¸°ë°˜ìœ¼ë¡œ ì‹¤ì œ ê°œë°œì— ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” êµ¬ì²´ì ì¸ ì½”ë“œ ì˜ˆì‹œë¥¼ ì œê³µí•©ë‹ˆë‹¤. ê° ê¸°ëŠ¥ë³„ë¡œ ëª…í™•í•œ ì¸í„°í˜ì´ìŠ¤ì™€ êµ¬í˜„ ë°©ë²•ì„ ì œì‹œí•˜ì—¬ ê°œë°œìê°€ ì¼ê´€ì„± ìˆê²Œ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆë„ë¡ ë„ì™€ì¤ë‹ˆë‹¤.